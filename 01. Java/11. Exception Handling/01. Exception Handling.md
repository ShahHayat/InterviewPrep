# Exception Handling in Java - Comprehensive Guide

## Table of Contents
1. [Understanding Exceptions](#1-understanding-exceptions)
2. [Exception Hierarchy](#2-exception-hierarchy)
3. [Types of Exceptions](#3-types-of-exceptions)
4. [Exception Handling Mechanisms](#4-exception-handling-mechanisms)
5. [Try-Catch-Finally Blocks](#5-try-catch-finally-blocks)
6. [Throw vs Throws](#6-throw-vs-throws)
7. [Custom Exceptions](#7-custom-exceptions)
8. [Checked vs Unchecked Exceptions](#8-checked-vs-unchecked-exceptions)
9. [Common Runtime Exceptions](#9-common-runtime-exceptions)
10. [Exception Propagation](#10-exception-propagation)
11. [Multi-Catch and Try-with-Resources](#11-multi-catch-and-try-with-resources)
12. [Exception Handling Best Practices](#12-exception-handling-best-practices)
13. [Performance Considerations](#13-performance-considerations)
14. [Exception Handling Patterns](#14-exception-handling-patterns)

---

## 1. Understanding Exceptions

### What is an Exception?
An **exception** is an **unexpected event** that disrupts the normal flow of program execution. It represents an error condition that occurs during runtime.

### Key Characteristics
- **Abnormal Condition**: Represents something that went wrong during program execution
- **Object Oriented**: Exceptions are objects that contain information about the error
- **Disruptive**: Interrupts the normal sequential execution of code
- **Recoverable**: Can be caught and handled to prevent program termination

### Exception Object Creation
When an exception occurs, the JVM creates an exception object containing:
1. **Error Message**: Description of what went wrong
2. **Stack Trace**: Call stack showing where the exception occurred
3. **Cause**: The underlying exception that caused this exception (if any)

### Exception Propagation Process
```
method30() ‚Üí Exception occurs! ‚Üí Create Exception Object
   ‚Üì (Can method30 handle it?) ‚Üí No ‚Üí Propagate up
method20() ‚Üí Can method20 handle it? ‚Üí No ‚Üí Propagate up
   ‚Üì  
method10() ‚Üí Can method10 handle it? ‚Üí No ‚Üí Propagate up
   ‚Üì  
main() ‚Üí Can main() handle it? ‚Üí No ‚Üí Program terminates
```

### Practical Example: Unhandled Exception
```java
public class ExceptionDemo {
    public static void main(String[] args) {
        ExceptionDemo demo = new ExceptionDemo();
        demo.method1();  // Exception propagates from here
    }
    
    private void method1() {
        method2();
    }
    
    private void method2() {
        method3();
    }
    
    private void method3() {
        int result = 50 / 0;  // ArithmeticException occurs here
        System.out.println("Result: " + result);
    }
}
```

**Output:**
```
Exception in thread "main" java.lang.ArithmeticException: / by zero
    at ExceptionDemo.method3(ExceptionDemo.java:12)
    at ExceptionDemo.method2(ExceptionDemo.java:8)
    at ExceptionDemo.method1(ExceptionDemo.java:5)
    at ExceptionDemo.main(ExceptionDemo.java:3)
```  

---

## 2. Exception Hierarchy

### The Exception Class Hierarchy
```
java.lang.Object
    ‚îî‚îÄ‚îÄ java.lang.Throwable
        ‚îú‚îÄ‚îÄ java.lang.Error
        ‚îÇ   ‚îú‚îÄ‚îÄ OutOfMemoryError
        ‚îÇ   ‚îú‚îÄ‚îÄ StackOverflowError
        ‚îÇ   ‚îî‚îÄ‚îÄ VirtualMachineError
        ‚îî‚îÄ‚îÄ java.lang.Exception
            ‚îú‚îÄ‚îÄ java.lang.RuntimeException (Unchecked)
            ‚îÇ   ‚îú‚îÄ‚îÄ ArithmeticException
            ‚îÇ   ‚îú‚îÄ‚îÄ NullPointerException
            ‚îÇ   ‚îú‚îÄ‚îÄ ArrayIndexOutOfBoundsException
            ‚îÇ   ‚îú‚îÄ‚îÄ IllegalArgumentException
            ‚îÇ   ‚îî‚îÄ‚îÄ ClassCastException
            ‚îî‚îÄ‚îÄ Checked Exceptions
                ‚îú‚îÄ‚îÄ IOException
                ‚îú‚îÄ‚îÄ SQLException
                ‚îú‚îÄ‚îÄ ClassNotFoundException
                ‚îî‚îÄ‚îÄ InterruptedException
```

### Key Classes Explained

#### Throwable
- **Root class** for all exceptions and errors
- Contains methods like `getMessage()`, `printStackTrace()`, `getCause()`

#### Error vs Exception
| **Error** | **Exception** |
|-----------|---------------|
| Serious problems that applications shouldn't catch | Conditions that applications might catch |
| JVM-related issues | Application-level problems |
| Examples: OutOfMemoryError, StackOverflowError | Examples: IOException, SQLException |

#### RuntimeException
- **Base class** for unchecked exceptions
- Exceptions that can occur during normal program execution
- Not required to be declared or caught

---

## 3. Types of Exceptions

### 3.1 Checked Exceptions
**Must be handled at compile time**

```java
// Compile-time error if not handled
public void readFile(String filename) throws IOException {
    FileReader file = new FileReader(filename);
    // IOException must be declared or caught
}

// Proper handling
public void readFileWithHandling(String filename) {
    try {
        FileReader file = new FileReader(filename);
        // File operations
    } catch (IOException e) {
        System.err.println("File error: " + e.getMessage());
    }
}
```

**Common Checked Exceptions:**
- `IOException` - Input/output operations
- `SQLException` - Database operations
- `ClassNotFoundException` - Class loading
- `InterruptedException` - Thread interruption

### 3.2 Unchecked Exceptions (Runtime Exceptions)
**Detected at runtime, not enforced at compile time**

```java
public class RuntimeExceptionExamples {
    public static void main(String[] args) {
        // These will compile but may throw exceptions at runtime
        
        // 1. ArithmeticException
        int result = 10 / 0;
        
        // 2. NullPointerException
        String str = null;
        int length = str.length();
        
        // 3. ArrayIndexOutOfBoundsException
        int[] arr = {1, 2, 3};
        System.out.println(arr[5]);
        
        // 4. ClassCastException
        Object obj = "String";
        Integer num = (Integer) obj;
    }
}
```

### 3.3 Error Types
**Serious problems that shouldn't be caught**

```java
public class ErrorExamples {
    // This will cause StackOverflowError
    public static void infiniteRecursion() {
        infiniteRecursion();
    }
    
    // This may cause OutOfMemoryError
    public static void memoryExhaustion() {
        List<byte[]> memory = new ArrayList<>();
        while (true) {
            memory.add(new byte[1024 * 1024]); // 1MB arrays
        }
    }
}
```  

---

## 4. Exception Handling Mechanisms

### 4.1 Declaration with `throws`
The `throws` keyword declares that a method might throw specific exceptions.

```java
public class FileProcessor {
    // Method declares it might throw IOException
    public void processFile(String filename) throws IOException, SecurityException {
        if (filename == null) {
            throw new IllegalArgumentException("Filename cannot be null");
        }
        
        // Code that might throw IOException
        BufferedReader reader = new BufferedReader(new FileReader(filename));
        // File processing logic
    }
    
    // Multiple exceptions can be declared
    public void connectToDatabase() throws SQLException, ClassNotFoundException {
        Class.forName("com.mysql.jdbc.Driver");
        DriverManager.getConnection("jdbc:mysql://localhost/test");
    }
}
```

### 4.2 Handling with Try-Catch
Basic exception handling using try-catch blocks.

```java
public class ExceptionHandlingDemo {
    public static void main(String[] args) {
        // Basic try-catch
        try {
            int result = divideNumbers(10, 0);
            System.out.println("Result: " + result);
        } catch (ArithmeticException e) {
            System.err.println("Division by zero error: " + e.getMessage());
        }
        
        // Handling checked exceptions
        try {
            FileProcessor processor = new FileProcessor();
            processor.processFile("data.txt");
        } catch (IOException e) {
            System.err.println("File operation failed: " + e.getMessage());
        } catch (SecurityException e) {
            System.err.println("Security error: " + e.getMessage());
        }
    }
    
    public static int divideNumbers(int a, int b) {
        return a / b;  // May throw ArithmeticException
    }
}
```

### 4.3 Exception Flow Control
```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ Try Block   ‚îÇ ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ Code        ‚îÇ               ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò               ‚îÇ
        ‚îÇ                     ‚îÇ
        ‚ñº                     ‚îÇ
   Exception?                 ‚îÇ
        ‚îÇ                     ‚îÇ
    ‚îå‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îê              ‚îå‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îê
    ‚îÇ  Yes  ‚îÇ              ‚îÇ No  ‚îÇ
    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò              ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
        ‚îÇ                     ‚îÇ
        ‚ñº                     ‚îÇ
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê               ‚îÇ
‚îÇ Catch Block ‚îÇ               ‚îÇ
‚îÇ Handle      ‚îÇ               ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò               ‚îÇ
        ‚îÇ                     ‚îÇ
        ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                  ‚ñº
        ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
        ‚îÇFinally Block‚îÇ
        ‚îÇ (Optional)  ‚îÇ
        ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                  ‚îÇ
                  ‚ñº
        ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
        ‚îÇ  Continue   ‚îÇ
        ‚îÇ Execution   ‚îÇ
        ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

---

## 5. Try-Catch-Finally Blocks

### 5.1 Basic Structure
```java
try {
    // Code that might throw an exception
} catch (SpecificException e) {
    // Handle specific exception
} catch (GeneralException e) {
    // Handle general exception
} finally {
    // Cleanup code - always executes
}
```

### 5.2 Multiple Catch Blocks
Order matters: catch more specific exceptions first.

```java
public class MultipleCatchDemo {
    public static void main(String[] args) {
        try {
            performOperations();
        } catch (ArithmeticException e) {
            // Handle arithmetic errors
            System.err.println("Math error: " + e.getMessage());
        } catch (ArrayIndexOutOfBoundsException e) {
            // Handle array access errors
            System.err.println("Array error: " + e.getMessage());
        } catch (RuntimeException e) {
            // Handle other runtime exceptions
            System.err.println("Runtime error: " + e.getMessage());
        } catch (Exception e) {
            // Handle any other exception
            System.err.println("General error: " + e.getMessage());
        }
    }
    
    private static void performOperations() {
        // Various operations that might throw different exceptions
    }
}
```

### 5.3 Finally Block Behavior
The `finally` block **always executes** regardless of whether an exception occurs.

```java
public class FinallyDemo {
    public static void demonstrateFinally() {
        try {
            System.out.println("In try block");
            int result = 10 / 0;  // ArithmeticException
            System.out.println("This won't print");
        } catch (ArithmeticException e) {
            System.out.println("In catch block");
            return;  // Even with return, finally executes
        } finally {
            System.out.println("In finally block - Always executes!");
        }
        System.out.println("After try-catch-finally");
    }
}
```

**Output:**
```
In try block
In catch block
In finally block - Always executes!
```

### 5.4 Finally vs Return
```java
public class FinallyReturnDemo {
    public static int testFinally() {
        try {
            return 1;
        } finally {
            return 2;  // This overrides the try return!
        }
    }
    
    public static int testFinallyWithoutReturn() {
        try {
            return 10;
        } finally {
            System.out.println("Finally executes");
            // No return here - try return value is used
        }
    }
}
```

### 5.5 Resource Management with Finally
```java
public class ResourceManagement {
    public void readFileOldWay(String filename) {
        BufferedReader reader = null;
        try {
            reader = new BufferedReader(new FileReader(filename));
            String line;
            while ((line = reader.readLine()) != null) {
                System.out.println(line);
            }
        } catch (IOException e) {
            System.err.println("Error reading file: " + e.getMessage());
        } finally {
            // Always close resources
            if (reader != null) {
                try {
                    reader.close();
                } catch (IOException e) {
                    System.err.println("Error closing reader: " + e.getMessage());
                }
            }
        }
    }
}
```  

---

## 6. Throw vs Throws

### 6.1 Comparison Table
| **`throw`** | **`throws`** |
|-------------|--------------|
| Used to **explicitly throw** an exception | Used to **declare** possible exceptions |
| Used inside method body | Used in method signature |
| Can throw only one exception at a time | Can declare multiple exceptions |
| Followed by an exception instance | Followed by exception class names |
| Example: `throw new Exception("Error!");` | Example: `void method() throws IOException, SQLException` |

### 6.2 Using `throw`
Explicitly throwing exceptions within method bodies.

```java
public class ThrowDemo {
    public static void validateAge(int age) {
        if (age < 0) {
            throw new IllegalArgumentException("Age cannot be negative");
        }
        if (age > 150) {
            throw new IllegalArgumentException("Age cannot exceed 150");
        }
        System.out.println("Valid age: " + age);
    }
    
    public static void processAmount(double amount) {
        if (amount <= 0) {
            throw new RuntimeException("Amount must be positive");
        }
        // Process the amount
    }
    
    // Throwing checked exceptions
    public static void connectToService() throws IOException {
        boolean connectionFailed = true; // Simulate condition
        if (connectionFailed) {
            throw new IOException("Failed to connect to external service");
        }
    }
}
```

### 6.3 Using `throws`
Declaring exceptions that a method might throw.

```java
public class ThrowsDemo {
    // Single exception declaration
    public void readFile(String filename) throws IOException {
        BufferedReader reader = new BufferedReader(new FileReader(filename));
        // File operations that might throw IOException
    }
    
    // Multiple exception declarations
    public void performDatabaseOperation() throws SQLException, ClassNotFoundException {
        Class.forName("com.mysql.cj.jdbc.Driver");
        Connection conn = DriverManager.getConnection("jdbc:mysql://localhost/test");
        // Database operations
    }
    
    // Propagating exceptions
    public void processData() throws IOException, SQLException {
        readFile("data.txt");        // IOException propagated
        performDatabaseOperation();  // SQLException, ClassNotFoundException propagated
    }
}
```

---

## 7. Custom Exceptions

### 7.1 Creating Custom Checked Exceptions
```java
// Custom checked exception
public class InsufficientFundsException extends Exception {
    private double amount;
    private double balance;
    
    public InsufficientFundsException(double amount, double balance) {
        super("Insufficient funds: Attempted to withdraw $" + amount + 
              ", but balance is $" + balance);
        this.amount = amount;
        this.balance = balance;
    }
    
    public double getAmount() {
        return amount;
    }
    
    public double getBalance() {
        return balance;
    }
}
```

### 7.2 Creating Custom Unchecked Exceptions
```java
// Custom unchecked exception
public class InvalidEmailFormatException extends RuntimeException {
    private String email;
    
    public InvalidEmailFormatException(String email) {
        super("Invalid email format: " + email);
        this.email = email;
    }
    
    public InvalidEmailFormatException(String email, Throwable cause) {
        super("Invalid email format: " + email, cause);
        this.email = email;
    }
    
    public String getEmail() {
        return email;
    }
}
```

### 7.3 Using Custom Exceptions
```java
public class BankAccount {
    private double balance;
    private String email;
    
    public BankAccount(double initialBalance) {
        this.balance = initialBalance;
    }
    
    // Using custom checked exception
    public void withdraw(double amount) throws InsufficientFundsException {
        if (amount > balance) {
            throw new InsufficientFundsException(amount, balance);
        }
        balance -= amount;
        System.out.println("Withdrawal successful. New balance: $" + balance);
    }
    
    // Using custom unchecked exception
    public void setEmail(String email) {
        if (!isValidEmail(email)) {
            throw new InvalidEmailFormatException(email);
        }
        this.email = email;
    }
    
    private boolean isValidEmail(String email) {
        return email != null && email.contains("@") && email.contains(".");
    }
}

public class CustomExceptionDemo {
    public static void main(String[] args) {
        BankAccount account = new BankAccount(100.0);
        
        // Handling custom checked exception
        try {
            account.withdraw(150.0);
        } catch (InsufficientFundsException e) {
            System.err.println("Transaction failed: " + e.getMessage());
            System.err.println("Attempted amount: $" + e.getAmount());
            System.err.println("Current balance: $" + e.getBalance());
        }
        
        // Handling custom unchecked exception
        try {
            account.setEmail("invalid-email");
        } catch (InvalidEmailFormatException e) {
            System.err.println("Email validation failed: " + e.getMessage());
            System.err.println("Invalid email: " + e.getEmail());
        }
    }
}
```

### 7.4 Exception Chaining
```java
public class ExceptionChainingDemo {
    public void processOrder() throws OrderProcessingException {
        try {
            validatePayment();
        } catch (PaymentException e) {
            // Wrap the original exception as the cause
            throw new OrderProcessingException("Order processing failed", e);
        }
    }
    
    private void validatePayment() throws PaymentException {
        try {
            // Simulate network call that throws IOException
            throw new IOException("Network timeout");
        } catch (IOException e) {
            throw new PaymentException("Payment validation failed", e);
        }
    }
}

class OrderProcessingException extends Exception {
    public OrderProcessingException(String message, Throwable cause) {
        super(message, cause);
    }
}

class PaymentException extends Exception {
    public PaymentException(String message, Throwable cause) {
        super(message, cause);
    }
}
```  

---

## 8. Checked vs Unchecked Exceptions

### 8.1 Detailed Comparison

| Aspect | **Checked Exceptions** | **Unchecked Exceptions** |
|--------|----------------------|--------------------------|
| **Compile-time Handling** | Must be handled or declared | No compile-time enforcement |
| **Inheritance** | Extend `Exception` (but not `RuntimeException`) | Extend `RuntimeException` |
| **Recovery Expectation** | Expected to recover from | Usually programming errors |
| **Performance** | Overhead from mandatory handling | Better performance |
| **Code Verbosity** | More verbose due to handling requirements | Cleaner code |

### 8.2 Checked Exception Examples
```java
public class CheckedExceptionExamples {
    // IOException - File operations
    public void readFile() throws IOException {
        FileReader file = new FileReader("data.txt");
        BufferedReader reader = new BufferedReader(file);
        String line = reader.readLine();
        reader.close();
    }
    
    // SQLException - Database operations
    public void queryDatabase() throws SQLException {
        Connection conn = DriverManager.getConnection("jdbc:mysql://localhost/test");
        Statement stmt = conn.createStatement();
        ResultSet rs = stmt.executeQuery("SELECT * FROM users");
        conn.close();
    }
    
    // ClassNotFoundException - Dynamic class loading
    public void loadClass() throws ClassNotFoundException {
        Class<?> clazz = Class.forName("com.example.DynamicClass");
        Object instance = clazz.newInstance();
    }
    
    // InterruptedException - Thread operations
    public void waitForCompletion() throws InterruptedException {
        Thread.sleep(5000);
    }
}
```

### 8.3 Unchecked Exception Examples
```java
public class UncheckedExceptionExamples {
    public void demonstrateRuntimeExceptions() {
        // NullPointerException
        String str = null;
        // int length = str.length(); // Would throw NPE
        
        // ArithmeticException
        // int result = 10 / 0; // Would throw ArithmeticException
        
        // ArrayIndexOutOfBoundsException
        int[] array = {1, 2, 3};
        // int value = array[5]; // Would throw ArrayIndexOutOfBoundsException
        
        // ClassCastException
        Object obj = "Hello";
        // Integer num = (Integer) obj; // Would throw ClassCastException
        
        // IllegalArgumentException
        validateInput(-5); // Will throw IllegalArgumentException
    }
    
    private void validateInput(int value) {
        if (value < 0) {
            throw new IllegalArgumentException("Value cannot be negative: " + value);
        }
    }
}
```

---

## 9. Common Runtime Exceptions

### 9.1 NullPointerException (NPE)
**Most common runtime exception in Java**

```java
public class NPEDemo {
    public void demonstrateNPE() {
        String str = null;
        
        // These will all throw NullPointerException:
        // int length = str.length();
        // char first = str.charAt(0);
        // String upper = str.toUpperCase();
        
        // Prevention techniques:
        if (str != null) {
            int length = str.length();
        }
        
        // Using Optional (Java 8+)
        Optional<String> optional = Optional.ofNullable(str);
        optional.ifPresent(s -> System.out.println(s.length()));
        
        // Using defensive programming
        String result = getString();
        if (result != null && !result.isEmpty()) {
            System.out.println("Result: " + result);
        }
    }
    
    private String getString() {
        return null; // Simulating method that might return null
    }
}
```

### 9.2 ArrayIndexOutOfBoundsException
```java
public class ArrayExceptionDemo {
    public void demonstrateArrayExceptions() {
        int[] numbers = {1, 2, 3, 4, 5};
        
        // Safe array access
        int index = 7;
        if (index >= 0 && index < numbers.length) {
            System.out.println("Value: " + numbers[index]);
        } else {
            System.out.println("Invalid index: " + index);
        }
        
        // Using enhanced for loop to avoid index issues
        for (int number : numbers) {
            System.out.println("Number: " + number);
        }
        
        // List alternative with bounds checking
        List<Integer> numberList = Arrays.asList(1, 2, 3, 4, 5);
        if (index < numberList.size()) {
            System.out.println("Value: " + numberList.get(index));
        }
    }
}
```

### 9.3 ClassCastException
```java
public class ClassCastDemo {
    public void demonstrateCasting() {
        Object obj = "Hello World";
        
        // Unsafe casting - will throw ClassCastException
        // Integer number = (Integer) obj;
        
        // Safe casting using instanceof
        if (obj instanceof String) {
            String str = (String) obj;
            System.out.println("String value: " + str);
        } else if (obj instanceof Integer) {
            Integer num = (Integer) obj;
            System.out.println("Integer value: " + num);
        }
        
        // Using generic methods to avoid casting
        processObject(obj);
    }
    
    private <T> void processObject(T obj) {
        System.out.println("Processing: " + obj.getClass().getName());
        System.out.println("Value: " + obj.toString());
    }
}
```

---

## 10. Exception Propagation

### 10.1 Understanding Propagation Chain
```java
public class ExceptionPropagationDemo {
    public static void main(String[] args) {
        try {
            level1();
        } catch (Exception e) {
            System.out.println("Caught in main: " + e.getMessage());
            e.printStackTrace();
        }
    }
    
    public static void level1() throws CustomException {
        System.out.println("Entering level1");
        level2();
        System.out.println("Exiting level1"); // This won't execute
    }
    
    public static void level2() throws CustomException {
        System.out.println("Entering level2");
        level3();
        System.out.println("Exiting level2"); // This won't execute
    }
    
    public static void level3() throws CustomException {
        System.out.println("Entering level3");
        throw new CustomException("Exception occurred in level3");
    }
}

class CustomException extends Exception {
    public CustomException(String message) {
        super(message);
    }
}
```

### 10.2 Propagation with Partial Handling
```java
public class PartialHandlingDemo {
    public void demonstratePartialHandling() {
        try {
            processData();
        } catch (DataProcessingException e) {
            System.err.println("Data processing failed: " + e.getMessage());
            // Log the full stack trace
            e.printStackTrace();
        }
    }
    
    public void processData() throws DataProcessingException {
        try {
            readFile();
            processFile();
        } catch (IOException e) {
            // Handle IOException but throw custom exception
            throw new DataProcessingException("Failed to process data file", e);
        } catch (ParseException e) {
            // Handle ParseException but throw custom exception
            throw new DataProcessingException("Failed to parse data", e);
        }
    }
    
    private void readFile() throws IOException {
        // Simulate file reading that throws IOException
        throw new IOException("File not found");
    }
    
    private void processFile() throws ParseException {
        // Simulate file processing that throws ParseException
        throw new ParseException("Invalid format", 0);
    }
}

class DataProcessingException extends Exception {
    public DataProcessingException(String message, Throwable cause) {
        super(message, cause);
    }
}
```

---

## 11. Multi-Catch and Try-with-Resources

### 11.1 Multi-Catch Blocks (Java 7+)
```java
public class MultiCatchDemo {
    public void demonstrateMultiCatch() {
        try {
            performOperations();
        } catch (IOException | SQLException e) {
            // Handle both exceptions the same way
            System.err.println("Operation failed: " + e.getMessage());
            logError(e);
        } catch (ClassNotFoundException | ParseException e) {
            // Handle these exceptions differently
            System.err.println("Configuration error: " + e.getMessage());
            resetToDefaults();
        }
    }
    
    private void performOperations() throws IOException, SQLException, 
                                          ClassNotFoundException, ParseException {
        // Method that might throw multiple types of exceptions
    }
    
    private void logError(Exception e) {
        // Log error details
    }
    
    private void resetToDefaults() {
        // Reset system to default state
    }
}
```

### 11.2 Try-with-Resources (Java 7+)
```java
public class TryWithResourcesDemo {
    // Old way - manual resource management
    public void readFileOldWay(String filename) {
        BufferedReader reader = null;
        try {
            reader = new BufferedReader(new FileReader(filename));
            String line;
            while ((line = reader.readLine()) != null) {
                System.out.println(line);
            }
        } catch (IOException e) {
            System.err.println("Error reading file: " + e.getMessage());
        } finally {
            if (reader != null) {
                try {
                    reader.close();
                } catch (IOException e) {
                    System.err.println("Error closing reader: " + e.getMessage());
                }
            }
        }
    }
    
    // New way - automatic resource management
    public void readFileNewWay(String filename) {
        try (BufferedReader reader = new BufferedReader(new FileReader(filename))) {
            String line;
            while ((line = reader.readLine()) != null) {
                System.out.println(line);
            }
        } catch (IOException e) {
            System.err.println("Error reading file: " + e.getMessage());
        }
        // reader.close() is automatically called
    }
    
    // Multiple resources
    public void copyFile(String source, String destination) {
        try (BufferedReader reader = new BufferedReader(new FileReader(source));
             BufferedWriter writer = new BufferedWriter(new FileWriter(destination))) {
            
            String line;
            while ((line = reader.readLine()) != null) {
                writer.write(line);
                writer.newLine();
            }
        } catch (IOException e) {
            System.err.println("Error copying file: " + e.getMessage());
        }
        // Both reader and writer are automatically closed
    }
}
```

### 11.3 Custom AutoCloseable Resources
```java
public class CustomResource implements AutoCloseable {
    private String resourceName;
    private boolean isOpen;
    
    public CustomResource(String name) {
        this.resourceName = name;
        this.isOpen = true;
        System.out.println("Opening resource: " + resourceName);
    }
    
    public void doWork() {
        if (!isOpen) {
            throw new IllegalStateException("Resource is closed");
        }
        System.out.println("Working with resource: " + resourceName);
    }
    
    @Override
    public void close() {
        if (isOpen) {
            System.out.println("Closing resource: " + resourceName);
            isOpen = false;
        }
    }
}

public class CustomResourceDemo {
    public void useCustomResource() {
        try (CustomResource resource = new CustomResource("Database Connection")) {
            resource.doWork();
            // Resource is automatically closed even if exception occurs
        } catch (Exception e) {
            System.err.println("Error using resource: " + e.getMessage());
        }
    }
}
```

---

## 12. Exception Handling Best Practices

### 12.1 When to Use Exception Handling
‚úÖ **Recoverable errors** (file not found, network timeouts)  
‚úÖ **Separating error handling from business logic**  
‚úÖ **Unexpected conditions** that shouldn't occur in normal flow  
‚úÖ **Cross-boundary communication** (between layers/modules)

### 12.2 When to Avoid Exception Handling
‚ùå **Normal program flow control** (use if-else instead)  
‚ùå **Performance-critical code** (exceptions are expensive)  
‚ùå **Expected conditions** (validation should use return values)  
‚ùå **Simple error cases** that can be handled with return codes

### 12.3 Code Examples: Good vs Bad Practices

#### Bad Practice - Using Exceptions for Flow Control
```java
// DON'T DO THIS
public int divide(int a, int b) {
    try {
        return a / b;
    } catch (ArithmeticException e) {
        return -1; // Using exception for normal case
    }
}
```

#### Good Practice - Validate Before Operation
```java
// DO THIS INSTEAD
public int divide(int a, int b) {
    if (b == 0) {
        return -1; // Or throw IllegalArgumentException
    }
    return a / b;
}

// Or better yet, use Optional
public Optional<Integer> divideOptional(int a, int b) {
    if (b == 0) {
        return Optional.empty();
    }
    return Optional.of(a / b);
}
```

### 12.4 Exception Handling Guidelines

#### 1. Be Specific with Catch Blocks
```java
// Bad - too general
try {
    processFile();
} catch (Exception e) {
    // What kind of exception? Hard to handle appropriately
}

// Good - specific handling
try {
    processFile();
} catch (FileNotFoundException e) {
    // Handle file not found
} catch (IOException e) {
    // Handle other I/O issues
} catch (SecurityException e) {
    // Handle permission issues
}
```

#### 2. Don't Ignore Exceptions
```java
// Bad - swallowing exceptions
try {
    riskyOperation();
} catch (Exception e) {
    // Silent failure - very bad!
}

// Good - at minimum, log the exception
try {
    riskyOperation();
} catch (Exception e) {
    logger.error("Operation failed", e);
    // Consider rethrowing or handling appropriately
}
```

#### 3. Provide Meaningful Error Messages
```java
// Bad - generic messages
throw new IllegalArgumentException("Invalid input");

// Good - specific, actionable messages
throw new IllegalArgumentException(
    "Email address cannot be null or empty. Provided value: " + email);
```

#### 4. Clean Up Resources Properly
```java
// Use try-with-resources for automatic cleanup
try (Connection conn = getConnection();
     PreparedStatement stmt = conn.prepareStatement(sql)) {
    // Database operations
} catch (SQLException e) {
    // Handle database errors
}
// Connection and statement automatically closed
```

---

## 13. Performance Considerations

### 13.1 Exception Creation Cost
```java
public class ExceptionPerformanceDemo {
    private static final int ITERATIONS = 1000000;
    
    public void measureExceptionCost() {
        // Measure normal execution
        long start = System.nanoTime();
        for (int i = 0; i < ITERATIONS; i++) {
            normalMethod();
        }
        long normalTime = System.nanoTime() - start;
        
        // Measure exception handling
        start = System.nanoTime();
        for (int i = 0; i < ITERATIONS; i++) {
            try {
                exceptionMethod();
            } catch (Exception e) {
                // Handle exception
            }
        }
        long exceptionTime = System.nanoTime() - start;
        
        System.out.println("Normal execution: " + normalTime / 1_000_000 + " ms");
        System.out.println("Exception handling: " + exceptionTime / 1_000_000 + " ms");
        System.out.println("Exception overhead: " + (exceptionTime / normalTime) + "x slower");
    }
    
    private void normalMethod() {
        // Normal execution path
    }
    
    private void exceptionMethod() throws Exception {
        throw new Exception("Test exception");
    }
}
```

### 13.2 Stack Trace Generation Cost
```java
public class StackTraceDemo {
    public void demonstrateStackTraceCost() {
        // Creating exception with stack trace (expensive)
        Exception withStackTrace = new Exception("With stack trace");
        
        // Creating exception without stack trace (cheaper)
        Exception withoutStackTrace = new Exception("Without stack trace") {
            @Override
            public Throwable fillInStackTrace() {
                return this; // Don't fill stack trace
            }
        };
        
        // Measure the difference
        measureCreationTime("With stack trace", () -> new Exception("Test"));
        measureCreationTime("Without stack trace", () -> new Exception("Test") {
            @Override
            public Throwable fillInStackTrace() {
                return this;
            }
        });
    }
    
    private void measureCreationTime(String label, Supplier<Exception> creator) {
        long start = System.nanoTime();
        for (int i = 0; i < 100000; i++) {
            Exception e = creator.get();
        }
        long duration = System.nanoTime() - start;
        System.out.println(label + ": " + duration / 1_000_000 + " ms");
    }
}
```

---

## 14. Exception Handling Patterns

### 14.1 Exception Translation Pattern
```java
public class ServiceLayer {
    private DataAccessLayer dataLayer = new DataAccessLayer();
    
    public User getUserById(Long id) throws ServiceException {
        try {
            return dataLayer.findUser(id);
        } catch (SQLException e) {
            // Translate low-level exception to service-level exception
            throw new ServiceException("Failed to retrieve user with ID: " + id, e);
        } catch (DataAccessException e) {
            throw new ServiceException("Data access error while retrieving user", e);
        }
    }
}

class ServiceException extends Exception {
    public ServiceException(String message, Throwable cause) {
        super(message, cause);
    }
}
```

### 14.2 Exception Aggregation Pattern
```java
public class BatchProcessor {
    public BatchResult processBatch(List<Item> items) {
        List<ProcessingException> errors = new ArrayList<>();
        List<Item> successfulItems = new ArrayList<>();
        
        for (Item item : items) {
            try {
                processItem(item);
                successfulItems.add(item);
            } catch (ProcessingException e) {
                errors.add(e);
                // Continue processing other items
            }
        }
        
        return new BatchResult(successfulItems, errors);
    }
    
    private void processItem(Item item) throws ProcessingException {
        // Process individual item
    }
}

class BatchResult {
    private final List<Item> successfulItems;
    private final List<ProcessingException> errors;
    
    public BatchResult(List<Item> successful, List<ProcessingException> errors) {
        this.successfulItems = successful;
        this.errors = errors;
    }
    
    public boolean hasErrors() {
        return !errors.isEmpty();
    }
    
    // Getters...
}
```

### 14.3 Circuit Breaker Pattern
```java
public class CircuitBreaker {
    private enum State { CLOSED, OPEN, HALF_OPEN }
    
    private State state = State.CLOSED;
    private int failureCount = 0;
    private long lastFailureTime = 0;
    private final int threshold = 5;
    private final long timeout = 60000; // 1 minute
    
    public <T> T execute(Supplier<T> operation) throws CircuitBreakerException {
        if (state == State.OPEN) {
            if (System.currentTimeMillis() - lastFailureTime >= timeout) {
                state = State.HALF_OPEN;
            } else {
                throw new CircuitBreakerException("Circuit breaker is OPEN");
            }
        }
        
        try {
            T result = operation.get();
            onSuccess();
            return result;
        } catch (Exception e) {
            onFailure();
            throw new CircuitBreakerException("Operation failed", e);
        }
    }
    
    private void onSuccess() {
        failureCount = 0;
        state = State.CLOSED;
    }
    
    private void onFailure() {
        failureCount++;
        lastFailureTime = System.currentTimeMillis();
        if (failureCount >= threshold) {
            state = State.OPEN;
        }
    }
}

class CircuitBreakerException extends Exception {
    public CircuitBreakerException(String message) {
        super(message);
    }
    
    public CircuitBreakerException(String message, Throwable cause) {
        super(message, cause);
    }
}
```

---

## Summary & Key Takeaways

### Exception Handling Principles
üìå **Use exceptions for exceptional conditions, not normal flow**  
üìå **Be specific with exception types and error messages**  
üìå **Always clean up resources using try-with-resources**  
üìå **Don't catch exceptions you can't handle meaningfully**  
üìå **Consider performance implications in critical code paths**  
üìå **Use custom exceptions for domain-specific errors**  
üìå **Follow the fail-fast principle**  

### Exception Hierarchy Summary
```
Throwable
‚îú‚îÄ‚îÄ Error (Don't catch these)
‚îÇ   ‚îú‚îÄ‚îÄ OutOfMemoryError
‚îÇ   ‚îú‚îÄ‚îÄ StackOverflowError
‚îÇ   ‚îî‚îÄ‚îÄ VirtualMachineError
‚îî‚îÄ‚îÄ Exception
    ‚îú‚îÄ‚îÄ RuntimeException (Unchecked)
    ‚îÇ   ‚îú‚îÄ‚îÄ NullPointerException
    ‚îÇ   ‚îú‚îÄ‚îÄ IllegalArgumentException
    ‚îÇ   ‚îú‚îÄ‚îÄ ArrayIndexOutOfBoundsException
    ‚îÇ   ‚îî‚îÄ‚îÄ ClassCastException
    ‚îî‚îÄ‚îÄ Checked Exceptions
        ‚îú‚îÄ‚îÄ IOException
        ‚îú‚îÄ‚îÄ SQLException
        ‚îî‚îÄ‚îÄ ClassNotFoundException
```

### Modern Exception Handling
- **Use Optional** for methods that might not return a value
- **Leverage try-with-resources** for automatic resource management
- **Consider CompletableFuture** for asynchronous exception handling
- **Use multi-catch** for similar exception handling logic
- **Implement proper logging** with appropriate log levels

By following these comprehensive guidelines and understanding the deep concepts of exception handling, you can write robust, maintainable, and efficient Java applications! üöÄ