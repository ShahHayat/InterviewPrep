# **Java Classes and Generics**
---

## **1. Types of Classes in Java**
Java supports various types of classes, each serving a specific purpose:

### **1.1 Concrete Class**
- **Definition**: A fully implemented class that can be instantiated using `new`.
- **Characteristics**:
    - All methods have complete implementations.
    - Can extend abstract classes or implement interfaces.
    - Access modifiers: `public` or package-private (default).
    - Can have constructors, fields, and methods.
    - Can be instantiated directly.
- **Example**:
  ```java
  public class Person {
      // Instance variables
      private int empID;
      private String name;
      private double salary;
      
      // Constructor
      public Person(int empID, String name, double salary) {
          this.empID = empID;
          this.name = name;
          this.salary = salary;
      }
      
      // Getters and Setters
      public int getEmpID() { return empID; }
      public void setEmpID(int empID) { this.empID = empID; }
      
      public String getName() { return name; }
      public void setName(String name) { this.name = name; }
      
      public double getSalary() { return salary; }
      public void setSalary(double salary) { this.salary = salary; }
      
      // Business logic methods
      public void giveRaise(double percentage) {
          this.salary += (this.salary * percentage / 100);
      }
      
      @Override
      public String toString() {
          return "Person{" +
                 "empID=" + empID +
                 ", name='" + name + '\'' +
                 ", salary=" + salary +
                 '}';
      }
  }
  
  // Usage
  Person person = new Person(1, "John Doe", 50000.0);
  person.giveRaise(10); // 10% raise
  System.out.println(person); // Prints person details
  ```

---

### **1.2 Abstract Class**
- **Definition**: A class declared with `abstract` that cannot be instantiated.
- **Characteristics**:
    - Supports **0-100% abstraction** (can have both abstract and concrete methods).
    - Used when multiple subclasses share common behavior.
    - Can have constructors (called via `super()` in child classes).
    - Can have instance variables and static members.
    - Can implement interfaces.
- **Example**:
  ```java
  public abstract class Vehicle {
      // Instance variables
      protected String brand;
      protected String model;
      protected int year;
      protected double price;
      
      // Constructor
      public Vehicle(String brand, String model, int year, double price) {
          this.brand = brand;
          this.model = model;
          this.year = year;
          this.price = price;
      }
      
      // Abstract methods (must be implemented by subclasses)
      public abstract void start();
      public abstract void stop();
      public abstract double calculateMaintenanceCost();
      
      // Concrete methods (shared by all subclasses)
      public void displayInfo() {
          System.out.println("Brand: " + brand);
          System.out.println("Model: " + model);
          System.out.println("Year: " + year);
          System.out.println("Price: $" + price);
      }
      
      public double getPrice() {
          return price;
      }
      
      public void setPrice(double price) {
          this.price = price;
      }
  }
  
  // Concrete subclass
  public class Car extends Vehicle {
      private int numberOfDoors;
      
      public Car(String brand, String model, int year, double price, int numberOfDoors) {
          super(brand, model, year, price);
          this.numberOfDoors = numberOfDoors;
      }
      
      @Override
      public void start() {
          System.out.println("Car engine started");
      }
      
      @Override
      public void stop() {
          System.out.println("Car engine stopped");
      }
      
      @Override
      public double calculateMaintenanceCost() {
          return price * 0.1; // 10% of price as maintenance cost
      }
      
      public int getNumberOfDoors() {
          return numberOfDoors;
      }
  }
  
  // Usage
  Car car = new Car("Toyota", "Camry", 2023, 25000.0, 4);
  car.displayInfo();
  car.start();
  System.out.println("Maintenance cost: $" + car.calculateMaintenanceCost());
  ```

---

### **1.3 Super Class & Sub Class**
- **Superclass**: The class being inherited from.
- **Subclass**: The class that inherits from another.
- **Key Points**:
    - Every class implicitly extends `Object` if no explicit superclass exists.
    - `Object` class provides methods like `toString()`, `equals()`, `hashCode()`.
    - Single inheritance in Java (a class can extend only one class).
    - Multiple interfaces can be implemented.
- **Example**:
  ```java
  // Superclass
  public class Animal {
      protected String name;
      protected int age;
      
      public Animal(String name, int age) {
          this.name = name;
          this.age = age;
      }
      
      public void makeSound() {
          System.out.println("Some generic animal sound");
      }
      
      public void displayInfo() {
          System.out.println("Name: " + name);
          System.out.println("Age: " + age);
      }
  }
  
  // Subclass
  public class Dog extends Animal {
      private String breed;
      
      public Dog(String name, int age, String breed) {
          super(name, age);
          this.breed = breed;
      }
      
      @Override
      public void makeSound() {
          System.out.println("Woof! Woof!");
      }
      
      public void fetch() {
          System.out.println(name + " is fetching the ball");
      }
      
      @Override
      public void displayInfo() {
          super.displayInfo();
          System.out.println("Breed: " + breed);
      }
  }
  
  // Usage
  Dog dog = new Dog("Buddy", 3, "Golden Retriever");
  dog.displayInfo();
  dog.makeSound();
  dog.fetch();
  
  // Polymorphism example
  Animal animal = new Dog("Max", 2, "German Shepherd");
  animal.makeSound(); // Calls Dog's makeSound method
  ```

---

### **1.4 Nested Classes**
A class defined inside another class for better encapsulation.

#### **1.4.1 Static Nested Class**
- **Characteristics**:
    - Does **not** have access to outer class instance variables.
    - Can be instantiated **without** an outer class object.
    - Can be `private`, `public`, `protected`, or package-private.
    - Can access static members of the outer class.
- **Example**:
  ```java
  public class Bank {
      private static double interestRate = 0.05;
      private String bankName;
      
      public Bank(String bankName) {
          this.bankName = bankName;
      }
      
      // Static nested class
      public static class Account {
          private String accountNumber;
          private double balance;
          
          public Account(String accountNumber, double balance) {
              this.accountNumber = accountNumber;
              this.balance = balance;
          }
          
          public void calculateInterest() {
              double interest = balance * interestRate;
              System.out.println("Interest: $" + interest);
          }
          
          public void displayInfo() {
              System.out.println("Account Number: " + accountNumber);
              System.out.println("Balance: $" + balance);
          }
      }
  }
  
  // Usage
  Bank.Account account = new Bank.Account("12345", 1000.0);
  account.displayInfo();
  account.calculateInterest();
  ```

#### **1.4.2 Non-Static Nested (Inner) Classes**
- **Member Inner Class**:
    - Can access all outer class members.
    - Requires outer class instance.
    - Can be `private`, `public`, `protected`, or package-private.
  ```java
  public class ShoppingCart {
      private String customerName;
      private List<Item> items;
      
      public ShoppingCart(String customerName) {
          this.customerName = customerName;
          this.items = new ArrayList<>();
      }
      
      // Member inner class
      public class Item {
          private String name;
          private double price;
          private int quantity;
          
          public Item(String name, double price, int quantity) {
              this.name = name;
              this.price = price;
              this.quantity = quantity;
          }
          
          public double getTotal() {
              return price * quantity;
          }
          
          public void displayInfo() {
              System.out.println("Item: " + name);
              System.out.println("Price: $" + price);
              System.out.println("Quantity: " + quantity);
              System.out.println("Total: $" + getTotal());
          }
      }
      
      public void addItem(String name, double price, int quantity) {
          Item item = new Item(name, price, quantity);
          items.add(item);
      }
      
      public void displayCart() {
          System.out.println("Customer: " + customerName);
          System.out.println("Items in cart:");
          for (Item item : items) {
              item.displayInfo();
          }
      }
  }
  
  // Usage - Method 1: Using outer class methods
  ShoppingCart cart = new ShoppingCart("John");
  cart.addItem("Laptop", 999.99, 1);
  cart.addItem("Mouse", 29.99, 2);
  cart.displayCart();
  
  // Usage - Method 2: Creating inner class instance directly
  ShoppingCart cart2 = new ShoppingCart("Alice");
  ShoppingCart.Item item1 = cart2.new Item("Keyboard", 79.99, 1);
  ShoppingCart.Item item2 = cart2.new Item("Monitor", 299.99, 1);
  
  // Display individual items
  item1.displayInfo();
  item2.displayInfo();
  ```

- **Local Inner Class**:
    - Defined inside a method/block.
    - Cannot be `public`, `private`, or `protected`.
    - Can access final or effectively final local variables.
  ```java
  public class Calculator {
      public void calculate(int x, int y) {
          // Local inner class
          class Operation {
              public int add() {
                  return x + y;
              }
              
              public int multiply() {
                  return x * y;
              }
          }
          
          Operation op = new Operation();
          System.out.println("Sum: " + op.add());
          System.out.println("Product: " + op.multiply());
      }
  }
  
  // Usage
  Calculator calc = new Calculator();
  calc.calculate(5, 3);
  ```

- **Anonymous Inner Class**:
    - No name, used for overriding methods.
    - Can implement an interface or extend a class.
  ```java
  public interface ClickListener {
      void onClick();
  }
  
  public class Button {
      private String label;
      private ClickListener listener;
      
      public Button(String label) {
          this.label = label;
      }
      
      public void setClickListener(ClickListener listener) {
          this.listener = listener;
      }
      
      public void click() {
          if (listener != null) {
              listener.onClick();
          }
      }
  }
  
  // Usage
  Button button = new Button("Submit");
  button.setClickListener(new ClickListener() {
      @Override
      public void onClick() {
          System.out.println("Button clicked!");
      }
  });
  button.click();
  ```

---

## **2. Inheritance in Nested Classes**

### **2.1 Static Nested Class Inheritance**
Static nested classes can inherit from other classes and can be inherited by other classes, just like regular top-level classes.

#### **2.1.1 Static Nested Class Extending Another Class**
```java
public class Vehicle {
    protected String brand;
    
    public Vehicle(String brand) {
        this.brand = brand;
    }
    
    public void displayBrand() {
        System.out.println("Brand: " + brand);
    }
}

public class Manufacturer {
    private static String companyName = "AutoCorp";
    
    // Static nested class extending another class
    public static class Car extends Vehicle {
        private int doors;
        
        public Car(String brand, int doors) {
            super(brand);
            this.doors = doors;
        }
        
        public void displayInfo() {
            displayBrand();
            System.out.println("Doors: " + doors);
            System.out.println("Manufacturer: " + companyName);
        }
    }
    
    // Another static nested class
    public static class Truck extends Vehicle {
        private double loadCapacity;
        
        public Truck(String brand, double loadCapacity) {
            super(brand);
            this.loadCapacity = loadCapacity;
        }
        
        public void displayInfo() {
            displayBrand();
            System.out.println("Load Capacity: " + loadCapacity + " tons");
            System.out.println("Manufacturer: " + companyName);
        }
    }
}

// Usage
Manufacturer.Car car = new Manufacturer.Car("Toyota", 4);
car.displayInfo();

Manufacturer.Truck truck = new Manufacturer.Truck("Ford", 5.5);
truck.displayInfo();
```

#### **2.1.2 Inheriting from Static Nested Class**
```java
public class Electronics {
    public static class Device {
        protected String model;
        protected double price;
        
        public Device(String model, double price) {
            this.model = model;
            this.price = price;
        }
        
        public void displayInfo() {
            System.out.println("Model: " + model);
            System.out.println("Price: $" + price);
        }
    }
}

// External class inheriting from static nested class
public class Smartphone extends Electronics.Device {
    private String operatingSystem;
    
    public Smartphone(String model, double price, String os) {
        super(model, price);
        this.operatingSystem = os;
    }
    
    @Override
    public void displayInfo() {
        super.displayInfo();
        System.out.println("OS: " + operatingSystem);
    }
    
    public void makeCall(String number) {
        System.out.println("Calling " + number + " from " + model);
    }
}

// Usage
Smartphone phone = new Smartphone("iPhone 15", 999.99, "iOS");
phone.displayInfo();
phone.makeCall("123-456-7890");
```

### **2.2 Non-Static Inner Class Inheritance**
Non-static inner classes have more complex inheritance rules due to their implicit reference to the outer class instance.

#### **2.2.1 Inner Class Extending Another Class**
```java
public class University {
    private String universityName;
    
    public University(String name) {
        this.universityName = name;
    }
    
    // Base class for inner class inheritance
    public class Person {
        protected String name;
        protected int age;
        
        public Person(String name, int age) {
            this.name = name;
            this.age = age;
        }
        
        public void displayBasicInfo() {
            System.out.println("Name: " + name);
            System.out.println("Age: " + age);
            System.out.println("University: " + universityName);
        }
    }
    
    // Inner class extending another inner class
    public class Student extends Person {
        private String studentId;
        private String major;
        
        public Student(String name, int age, String studentId, String major) {
            super(name, age);
            this.studentId = studentId;
            this.major = major;
        }
        
        @Override
        public void displayBasicInfo() {
            super.displayBasicInfo();
            System.out.println("Student ID: " + studentId);
            System.out.println("Major: " + major);
        }
        
        public void study() {
            System.out.println(name + " is studying " + major + " at " + universityName);
        }
    }
    
    // Another inner class extending Person
    public class Professor extends Person {
        private String department;
        private double salary;
        
        public Professor(String name, int age, String department, double salary) {
            super(name, age);
            this.department = department;
            this.salary = salary;
        }
        
        @Override
        public void displayBasicInfo() {
            super.displayBasicInfo();
            System.out.println("Department: " + department);
            System.out.println("Salary: $" + salary);
        }
        
        public void teach() {
            System.out.println("Prof. " + name + " is teaching in " + department + " at " + universityName);
        }
    }
}

// Usage
University university = new University("MIT");

University.Student student = university.new Student("John Doe", 20, "S12345", "Computer Science");
student.displayBasicInfo();
student.study();

University.Professor professor = university.new Professor("Dr. Smith", 45, "Computer Science", 85000);
professor.displayBasicInfo();
professor.teach();
```

#### **2.2.2 External Class Inheriting from Inner Class**
This is more complex and requires special syntax:

```java
public class Company {
    private String companyName;
    
    public Company(String name) {
        this.companyName = name;
    }
    
    public class Employee {
        protected String name;
        protected String position;
        
        public Employee(String name, String position) {
            this.name = name;
            this.position = position;
        }
        
        public void work() {
            System.out.println(name + " is working as " + position + " at " + companyName);
        }
        
        public void displayInfo() {
            System.out.println("Employee: " + name);
            System.out.println("Position: " + position);
            System.out.println("Company: " + companyName);
        }
    }
}

// External class inheriting from inner class
public class Manager extends Company.Employee {
    private int teamSize;
    
    // Special constructor required for inheriting from inner class
    public Manager(Company company, String name, String position, int teamSize) {
        company.super(name, position); // Special syntax
        this.teamSize = teamSize;
    }
    
    @Override
    public void work() {
        super.work();
        System.out.println("Managing a team of " + teamSize + " people");
    }
    
    @Override
    public void displayInfo() {
        super.displayInfo();
        System.out.println("Team Size: " + teamSize);
    }
    
    public void conductMeeting() {
        System.out.println(name + " is conducting a team meeting");
    }
}

// Usage
Company company = new Company("TechCorp");
Manager manager = new Manager(company, "Alice Johnson", "Senior Manager", 8);
manager.displayInfo();
manager.work();
manager.conductMeeting();
```

### **2.3 Inheritance Rules and Limitations**

#### **2.3.1 Static Nested Class Rules**
- Can extend any accessible class
- Can be extended by any class (static nested or top-level)
- No special syntax required
- Cannot access non-static members of outer class

#### **2.3.2 Non-Static Inner Class Rules**
- Can extend other classes (including other inner classes)
- External classes can inherit from inner classes but require special constructor syntax
- Must have access to outer class instance
- Can access all members of outer class

#### **2.3.3 Example of Complex Inheritance Hierarchy**
```java
public class Organization {
    private String orgName;
    
    public Organization(String name) {
        this.orgName = name;
    }
    
    // Base inner class
    public class Member {
        protected String name;
        protected String email;
        
        public Member(String name, String email) {
            this.name = name;
            this.email = email;
        }
        
        public void sendEmail(String message) {
            System.out.println("Sending email to " + email + ": " + message);
        }
    }
    
    // Inner class extending Member
    public class Staff extends Member {
        protected String department;
        
        public Staff(String name, String email, String department) {
            super(name, email);
            this.department = department;
        }
        
        public void clockIn() {
            System.out.println(name + " from " + department + " clocked in at " + orgName);
        }
    }
    
    // Inner class extending Staff
    public class Manager extends Staff {
        private int teamSize;
        
        public Manager(String name, String email, String department, int teamSize) {
            super(name, email, department);
            this.teamSize = teamSize;
        }
        
        public void delegateTask(String task) {
            System.out.println("Manager " + name + " delegating task: " + task);
        }
        
        @Override
        public void clockIn() {
            super.clockIn();
            System.out.println("Reviewing team of " + teamSize + " members");
        }
    }
}

// Usage
Organization org = new Organization("Global Tech");

Organization.Member member = org.new Member("John", "john@globaltech.com");
member.sendEmail("Welcome to the organization!");

Organization.Staff staff = org.new Staff("Jane", "jane@globaltech.com", "Engineering");
staff.clockIn();
staff.sendEmail("Daily standup at 9 AM");

Organization.Manager manager = org.new Manager("Bob", "bob@globaltech.com", "Engineering", 5);
manager.clockIn();
manager.delegateTask("Code review for new feature");
```

### **2.4 Best Practices for Nested Class Inheritance**

1. **Keep inheritance hierarchies simple** in nested classes
2. **Use static nested classes** when inheritance doesn't require outer class access
3. **Be cautious with external classes inheriting from inner classes** due to complexity
4. **Document the relationship** between outer and inner classes clearly
5. **Consider composition over inheritance** for complex nested class relationships

---

## **3. Specialized Class Types**

### **3.1 POJO (Plain Old Java Object)**
- **Definition**: A simple Java class with private fields, public getters/setters, and no business logic.
- **Characteristics**:
    - Does **not** extend predefined classes (e.g., `Servlet`, `EJB`).
    - Does **not** implement interfaces forced by frameworks.
    - Contains no annotations (e.g., `@Entity`, `@Autowired`).
    - Follows Java Bean naming conventions.
    - Serializable by default.
- **Example**:
  ```java
  public class Student implements Serializable {
      // Private fields
      private Long id;
      private String firstName;
      private String lastName;
      private String email;
      private Date dateOfBirth;
      private List<String> courses;
      
      // Default constructor
      public Student() {
          this.courses = new ArrayList<>();
      }
      
      // Parameterized constructor
      public Student(Long id, String firstName, String lastName, String email, Date dateOfBirth) {
          this();
          this.id = id;
          this.firstName = firstName;
          this.lastName = lastName;
          this.email = email;
          this.dateOfBirth = dateOfBirth;
      }
      
      // Getters and Setters
      public Long getId() { return id; }
      public void setId(Long id) { this.id = id; }
      
      public String getFirstName() { return firstName; }
      public void setFirstName(String firstName) { this.firstName = firstName; }
      
      public String getLastName() { return lastName; }
      public void setLastName(String lastName) { this.lastName = lastName; }
      
      public String getEmail() { return email; }
      public void setEmail(String email) { this.email = email; }
      
      public Date getDateOfBirth() { return dateOfBirth; }
      public void setDateOfBirth(Date dateOfBirth) { this.dateOfBirth = dateOfBirth; }
      
      public List<String> getCourses() { return new ArrayList<>(courses); }
      public void setCourses(List<String> courses) { this.courses = new ArrayList<>(courses); }
      
      // Utility methods
      public void addCourse(String course) {
          this.courses.add(course);
      }
      
      public void removeCourse(String course) {
          this.courses.remove(course);
      }
      
      @Override
      public String toString() {
          return "Student{" +
                 "id=" + id +
                 ", firstName='" + firstName + '\'' +
                 ", lastName='" + lastName + '\'' +
                 ", email='" + email + '\'' +
                 ", dateOfBirth=" + dateOfBirth +
                 ", courses=" + courses +
                 '}';
      }
  }
  
  // Usage
  Student student = new Student();
  student.setId(1L);
  student.setFirstName("John");
  student.setLastName("Doe");
  student.setEmail("john.doe@example.com");
  student.setDateOfBirth(new Date());
  student.addCourse("Java Programming");
  student.addCourse("Data Structures");
  System.out.println(student);
  ```

---

### **3.2 ENUM Class**
- **Definition**: A special class representing a fixed set of constants.
- **Characteristics**:
    - Implicitly extends `java.lang.Enum`.
    - Can have fields, methods, and constructors (must be `private`).
    - Used in `switch` statements, collections, and as singletons.
    - Thread-safe by default.
    - Can implement interfaces.
- **Example**:
  ```java
  public enum DayOfWeek {
      // Enum constants
      MONDAY("Weekday", 1),
      TUESDAY("Weekday", 2),
      WEDNESDAY("Weekday", 3),
      THURSDAY("Weekday", 4),
      FRIDAY("Weekday", 5),
      SATURDAY("Weekend", 6),
      SUNDAY("Weekend", 7);
      
      // Fields
      private final String type;
      private final int dayNumber;
      
      // Constructor
      private DayOfWeek(String type, int dayNumber) {
          this.type = type;
          this.dayNumber = dayNumber;
      }
      
      // Methods
      public String getType() { return type; }
      public int getDayNumber() { return dayNumber; }
      
      public boolean isWeekend() {
          return type.equals("Weekend");
      }
      
      public DayOfWeek nextDay() {
          DayOfWeek[] days = values();
          return days[(this.ordinal() + 1) % days.length];
      }
      
      public static DayOfWeek fromString(String day) {
          for (DayOfWeek d : values()) {
              if (d.name().equalsIgnoreCase(day)) {
                  return d;
              }
          }
          throw new IllegalArgumentException("Invalid day: " + day);
      }
  }
  
  // Usage
  DayOfWeek today = DayOfWeek.MONDAY;
  System.out.println("Today is " + today.name());
  System.out.println("Type: " + today.getType());
  System.out.println("Day number: " + today.getDayNumber());
  System.out.println("Is weekend? " + today.isWeekend());
  System.out.println("Next day: " + today.nextDay());
  
  // Switch statement example
  switch (today) {
      case MONDAY:
          System.out.println("Start of the week");
          break;
      case FRIDAY:
          System.out.println("End of the work week");
          break;
      case SATURDAY:
      case SUNDAY:
          System.out.println("Weekend");
          break;
      default:
          System.out.println("Middle of the week");
  }
  ```

---

### **3.3 Final Class**
- **Definition**: A class marked with `final` that cannot be subclassed.
- **Characteristics**:
    - Prevents inheritance (security/immutability).
    - All methods are implicitly `final`.
    - Examples: `String`, `Integer`, `Math`.
    - Can be instantiated but not extended.
- **Example**:
  ```java
  public final class ImmutablePoint {
      // Final fields
      private final double x;
      private final double y;
      
      // Constructor
      public ImmutablePoint(double x, double y) {
          this.x = x;
          this.y = y;
      }
      
      // Getters
      public double getX() { return x; }
      public double getY() { return y; }
      
      // Methods
      public double distanceTo(ImmutablePoint other) {
          double dx = this.x - other.x;
          double dy = this.y - other.y;
          return Math.sqrt(dx * dx + dy * dy);
      }
      
      public ImmutablePoint translate(double dx, double dy) {
          return new ImmutablePoint(this.x + dx, this.y + dy);
      }
      
      @Override
      public boolean equals(Object obj) {
          if (this == obj) return true;
          if (!(obj instanceof ImmutablePoint)) return false;
          ImmutablePoint other = (ImmutablePoint) obj;
          return Double.compare(other.x, x) == 0 && Double.compare(other.y, y) == 0;
      }
      
      @Override
      public int hashCode() {
          return Objects.hash(x, y);
      }
      
      @Override
      public String toString() {
          return "Point(" + x + ", " + y + ")";
      }
  }
  
  // Usage
  ImmutablePoint p1 = new ImmutablePoint(0, 0);
  ImmutablePoint p2 = new ImmutablePoint(3, 4);
  System.out.println("Distance: " + p1.distanceTo(p2));
  ImmutablePoint p3 = p1.translate(1, 1);
  System.out.println("Translated point: " + p3);
  ```

---

### **3.4 Singleton Class**
- **Definition**: A class that allows only **one instance** per JVM.
- **Characteristics**:
    - Private constructor.
    - Static instance variable.
    - Global access point via `getInstance()`.
    - Thread-safe implementation.
    - Lazy initialization option.
- **Implementation (Thread-Safe with Double-Checked Locking)**:
  ```java
  public class Database {
      // Volatile keyword ensures visibility of changes across threads
      private static volatile Database instance;
      private final String connectionString;
      private final Map<String, Object> cache;
      
      // Private constructor
      private Database(String connectionString) {
          this.connectionString = connectionString;
          this.cache = new ConcurrentHashMap<>();
          // Initialize database connection
          initializeConnection();
      }
      
      // Thread-safe getInstance method with double-checked locking
      public static Database getInstance(String connectionString) {
          if (instance == null) {
              synchronized (Database.class) {
                  if (instance == null) {
                      instance = new Database(connectionString);
                  }
              }
          }
          return instance;
      }
      
      private void initializeConnection() {
          // Simulate database connection initialization
          System.out.println("Initializing database connection: " + connectionString);
      }
      
      // Database operations
      public void query(String sql) {
          System.out.println("Executing query: " + sql);
      }
      
      public void cacheData(String key, Object value) {
          cache.put(key, value);
      }
      
      public Object getCachedData(String key) {
          return cache.get(key);
      }
      
      // Prevent cloning
      @Override
      protected Object clone() throws CloneNotSupportedException {
          throw new CloneNotSupportedException("Singleton cannot be cloned");
      }
      
      // Prevent serialization
      protected Object readResolve() {
          return instance;
      }
  }
  
  // Usage
  Database db1 = Database.getInstance("jdbc:mysql://localhost:3306/mydb");
  Database db2 = Database.getInstance("jdbc:mysql://localhost:3306/mydb");
  System.out.println("Same instance? " + (db1 == db2)); // true
  
  db1.query("SELECT * FROM users");
  db1.cacheData("user:1", "John Doe");
  System.out.println("Cached data: " + db2.getCachedData("user:1"));
  ```

---

### **3.5 Immutable Class**
- **Definition**: A class whose state **cannot change** after creation.
- **Rules**:
    1. Declare the class as `final`.
    2. Make all fields `private` and `final`.
    3. No setter methods.
    4. Return deep copies of mutable objects.
    5. Initialize all fields in constructor.
- **Example**:
  ```java
  public final class ImmutableStudent {
      private final String name;
      private final int age;
      private final List<String> courses;
      private final Map<String, Double> grades;
      private final Address address;
      
      public ImmutableStudent(String name, int age, List<String> courses,
                            Map<String, Double> grades, Address address) {
          this.name = name;
          this.age = age;
          this.courses = new ArrayList<>(courses); // Defensive copy
          this.grades = new HashMap<>(grades); // Defensive copy
          this.address = new Address(address.getStreet(), address.getCity()); // Defensive copy
      }
      
      // Getters return defensive copies
      public String getName() { return name; }
      public int getAge() { return age; }
      public List<String> getCourses() { return new ArrayList<>(courses); }
      public Map<String, Double> getGrades() { return new HashMap<>(grades); }
      public Address getAddress() { return new Address(address.getStreet(), address.getCity()); }
      
      // Business methods
      public double getAverageGrade() {
          return grades.values().stream()
                      .mapToDouble(Double::doubleValue)
                      .average()
                      .orElse(0.0);
      }
      
      public boolean isPassing() {
          return getAverageGrade() >= 60.0;
      }
      
      @Override
      public String toString() {
          return "Student{" +
                 "name='" + name + '\'' +
                 ", age=" + age +
                 ", courses=" + courses +
                 ", grades=" + grades +
                 ", address=" + address +
                 '}';
      }
  }
  
  // Immutable Address class
  public final class Address {
      private final String street;
      private final String city;
      
      public Address(String street, String city) {
          this.street = street;
          this.city = city;
      }
      
      public String getStreet() { return street; }
      public String getCity() { return city; }
      
      @Override
      public String toString() {
          return "Address{" +
                 "street='" + street + '\'' +
                 ", city='" + city + '\'' +
                 '}';
      }
  }
  
  // Usage
  List<String> courses = Arrays.asList("Math", "Science", "English");
  Map<String, Double> grades = new HashMap<>();
  grades.put("Math", 85.0);
  grades.put("Science", 90.0);
  grades.put("English", 88.0);
  
  Address address = new Address("123 Main St", "New York");
  ImmutableStudent student = new ImmutableStudent("John", 20, courses, grades, address);
  
  System.out.println("Student: " + student);
  System.out.println("Average Grade: " + student.getAverageGrade());
  System.out.println("Is Passing: " + student.isPassing());
  ```

---

### **3.6 Wrapper Class**
- **Definition**: Classes that wrap primitive types into objects.
- **Purpose**:
    - Enable primitives to be used in collections (`List<Integer>`).
    - Provide utility methods (`Integer.parseInt()`).
    - Support null values.
- **Primitive â†” Wrapper**:

| **Primitive** | **Wrapper Class** | **Size (bits)** | **Range** |
|--------------|------------------|----------------|-----------|
| `byte`       | `Byte`           | 8              | -128 to 127 |
| `short`      | `Short`          | 16             | -32,768 to 32,767 |
| `int`        | `Integer`        | 32             | -2^31 to 2^31-1 |
| `long`       | `Long`           | 64             | -2^63 to 2^63-1 |
| `float`      | `Float`          | 32             | Â±1.4E-45 to Â±3.4E+38 |
| `double`     | `Double`         | 64             | Â±4.9E-324 to Â±1.7E+308 |
| `char`       | `Character`      | 16             | '\u0000' to '\uffff' |
| `boolean`    | `Boolean`        | 1              | true/false |

- **Example**:
  ```java
  public class WrapperExample {
      public static void main(String[] args) {
          // Autoboxing (primitive to wrapper)
          Integer num1 = 100;
          Double num2 = 3.14;
          Character ch = 'A';
          Boolean flag = true;
          
          // Unboxing (wrapper to primitive)
          int i = num1;
          double d = num2;
          char c = ch;
          boolean b = flag;
          
          // Utility methods
          String numberStr = "123";
          int parsedInt = Integer.parseInt(numberStr);
          System.out.println("Parsed integer: " + parsedInt);
          
          // Binary, octal, hexadecimal conversion
          String binary = Integer.toBinaryString(42);
          String octal = Integer.toOctalString(42);
          String hex = Integer.toHexString(42);
          System.out.println("Binary: " + binary);
          System.out.println("Octal: " + octal);
          System.out.println("Hex: " + hex);
          
          // Character methods
          System.out.println("Is digit: " + Character.isDigit('5'));
          System.out.println("Is letter: " + Character.isLetter('A'));
          System.out.println("Is whitespace: " + Character.isWhitespace(' '));
          
          // Boolean operations
          Boolean result = Boolean.logicalAnd(true, false);
          System.out.println("Logical AND: " + result);
          
          // Collections with wrappers
          List<Integer> numbers = new ArrayList<>();
          numbers.add(1);
          numbers.add(2);
          numbers.add(3);
          System.out.println("Numbers: " + numbers);
          
          // Null handling
          Integer nullable = null;
          int defaultValue = nullable != null ? nullable : 0;
          System.out.println("Default value: " + defaultValue);
      }
  }
  ```

---

## **4. Summary Table**

| **Class Type**   | **Key Feature**                          | **Example**               |  
|------------------|----------------------------------------|--------------------------|  
| **POJO**         | No framework dependency, private fields | `Employee` class         |  
| **ENUM**         | Fixed constants, methods allowed       | `Day.MONDAY`             |  
| **Final**        | Cannot be subclassed                   | `String`, `Integer`      |  
| **Singleton**    | One instance per JVM                   | `Database.getInstance()` |  
| **Immutable**    | State never changes                    | `String`, `LocalDate`    |  
| **Wrapper**      | Primitives as objects                  | `Integer`, `Character`   |  

---

## **5. When to Use Which?**
- **POJO**: Simple data carriers (DTOs).
- **ENUM**: Fixed constants (e.g., status codes).
- **Final**: Security/immutability requirements.
- **Singleton**: Global access (logging, DB).
- **Immutable**: Thread-safe shared objects.
- **Wrapper**: Collections, utility methods.

This expanded guide now covers **all class types** from the PDF, including POJO, ENUM, Final, Singleton, Immutable, and Wrapper classes. ðŸŽ¯

---

## **6. Generic Classes & Methods**
### **6.1 Generic Class**
- **Purpose**: Create reusable, type-safe classes.
- **Syntax**:
  ```java
  public class Container<T> {
      private T value;
      
      public Container(T value) {
          this.value = value;
      }
      
      public T getValue() {
          return value;
      }
      
      public void setValue(T value) {
          this.value = value;
      }
      
      public boolean isEmpty() {
          return value == null;
      }
      
      @Override
      public String toString() {
          return "Container{" +
                 "value=" + value +
                 '}';
      }
  }
  
  // Usage
  Container<String> stringContainer = new Container<>("Hello");
  Container<Integer> intContainer = new Container<>(42);
  Container<Double> doubleContainer = new Container<>(3.14);
  
  System.out.println(stringContainer.getValue()); // Hello
  System.out.println(intContainer.getValue()); // 42
  System.out.println(doubleContainer.getValue()); // 3.14
  ```

### **6.2 Bounded Generics**
- **Upper Bound (`<T extends Class>`)**
    - Restricts to a class and its subclasses.
    - Can have multiple bounds using `&`.
  ```java
  public class NumberContainer<T extends Number & Comparable<T>> {
      private T value;
      
      public NumberContainer(T value) {
          this.value = value;
      }
      
      public T getValue() {
          return value;
      }
      
      public double getDoubleValue() {
          return value.doubleValue();
      }
      
      public int compareTo(NumberContainer<T> other) {
          return value.compareTo(other.value);
      }
  }
  
  // Usage
  NumberContainer<Integer> intContainer = new NumberContainer<>(42);
  NumberContainer<Double> doubleContainer = new NumberContainer<>(3.14);
  // NumberContainer<String> stringContainer = new NumberContainer<>("Hello"); // Compile error
  
  System.out.println(intContainer.getDoubleValue()); // 42.0
  System.out.println(doubleContainer.getDoubleValue()); // 3.14
  ```

- **Lower Bound (`<T super Class>`)**
    - Restricts to a class and its superclasses.
    - Used in method parameters.
  ```java
  public class Animal { }
  public class Dog extends Animal { }
  public class Labrador extends Dog { }
  
  public class AnimalContainer<T> {
      private List<T> animals = new ArrayList<>();
      
      public void addAll(List<? extends T> list) {
          animals.addAll(list);
      }
      
      public void addToContainer(List<? super T> list) {
          list.addAll(animals);
      }
  }
  
  // Usage
  AnimalContainer<Dog> dogContainer = new AnimalContainer<>();
  List<Labrador> labradors = Arrays.asList(new Labrador(), new Labrador());
  List<Animal> animals = new ArrayList<>();
  
  dogContainer.addAll(labradors); // OK: Labrador is a subtype of Dog
  dogContainer.addToContainer(animals); // OK: Animal is a supertype of Dog
  ```

### **6.3 Wildcards**
- **Upper Bound (`? extends Class`)**
    - Accepts the class and its subclasses.
    - Read-only access.
  ```java
  public class Box<T> {
      private T value;
      
      public Box(T value) {
          this.value = value;
      }
      
      public T getValue() {
          return value;
      }
  }
  
  public class BoxUtils {
      public static double sumOfNumbers(List<? extends Number> numbers) {
          return numbers.stream()
                       .mapToDouble(Number::doubleValue)
                       .sum();
      }
      
      public static void printBoxes(List<? extends Box<?>> boxes) {
          for (Box<?> box : boxes) {
              System.out.println(box.getValue());
          }
      }
  }
  
  // Usage
  List<Integer> integers = Arrays.asList(1, 2, 3, 4, 5);
  List<Double> doubles = Arrays.asList(1.1, 2.2, 3.3);
  
  System.out.println(BoxUtils.sumOfNumbers(integers)); // 15.0
  System.out.println(BoxUtils.sumOfNumbers(doubles)); // 6.6
  
  List<Box<String>> stringBoxes = Arrays.asList(
      new Box<>("Hello"),
      new Box<>("World")
  );
  BoxUtils.printBoxes(stringBoxes);
  ```

- **Lower Bound (`? super Class`)**
    - Accepts the class and its superclasses.
    - Write-only access.
  ```java
  public class CollectionUtils {
      public static <T> void addNumbers(List<? super T> list, T... numbers) {
          Collections.addAll(list, numbers);
      }
      
      public static <T> void copy(List<? super T> dest, List<? extends T> src) {
          dest.addAll(src);
      }
  }
  
  // Usage
  List<Number> numbers = new ArrayList<>();
  CollectionUtils.addNumbers(numbers, 1, 2, 3, 4, 5);
  
  List<Integer> integers = Arrays.asList(1, 2, 3);
  List<Number> numberList = new ArrayList<>();
  CollectionUtils.copy(numberList, integers);
  ```

- **Unbounded (`?`)**
    - Accepts any type.
    - Limited to methods of `Object`.
  ```java
  public class GenericUtils {
      public static void printList(List<?> list) {
          for (Object item : list) {
              System.out.println(item);
          }
      }
      
      public static boolean containsNull(List<?> list) {
          return list.contains(null);
      }
  }
  
  // Usage
  List<String> strings = Arrays.asList("Hello", "World");
  List<Integer> integers = Arrays.asList(1, 2, 3);
  
  GenericUtils.printList(strings);
  GenericUtils.printList(integers);
  ```

---

## **7. Type Erasure**
- **Concept**: Generics are removed at compile-time and replaced with raw types.
- **Examples**:
    - `Container<T>` â†’ `Container` (`T` becomes `Object`).
    - `Container<T extends Number>` â†’ `Container` (`T` becomes `Number`).
    - Generic methods â†’ Methods with `Object` parameters.
- **Example**:
  ```java
  public class TypeErasureExample {
      public static void main(String[] args) {
          // At compile time
          List<String> strings = new ArrayList<>();
          strings.add("Hello");
          String s = strings.get(0);
          
          // After type erasure (at runtime)
          List rawList = new ArrayList();
          rawList.add("Hello");
          String s2 = (String) rawList.get(0); // Cast required
          
          // Type erasure in methods
          printList(strings);
          printList(rawList);
      }
      
      public static void printList(List<?> list) {
          for (Object item : list) {
              System.out.println(item);
          }
      }
  }
  ```

---

## **8. Key Comparisons**
| **Feature**          | **Static Nested Class** | **Inner Class** |
|----------------------|------------------------|----------------|
| **Access to Outer**  | Only static members    | All members    |
| **Instantiation**    | Without outer object   | Needs outer object |
| **Memory**          | Lighter (no ref to outer) | Heavier (holds ref) |
| **Static Members**   | Allowed               | Not allowed    |
| **Access Modifiers** | All allowed           | All allowed    |

| **Concept**       | **Generics** | **Wildcards** |
|------------------|-------------|--------------|
| **Type Safety**  | Strong (compile-time) | Less strict |
| **Flexibility**  | Fixed type  | More flexible |
| **Usage**        | Class/Method definitions | Method parameters |
| **Bounds**       | Can be bounded | Can be bounded |
| **Type Erasure** | Yes         | Yes          |

---

## **9. Best Practices**
1. **Use nested classes** when a class is only used by one other class.
   ```java
   public class Outer {
       private static class Helper {
           // Helper implementation
       }
   }
   ```

2. **Prefer static nested classes** unless instance access is needed.
   ```java
   public class Cache {
       private static class CacheEntry {
           private final Object key;
           private final Object value;
           private final long timestamp;
           
           public CacheEntry(Object key, Object value) {
               this.key = key;
               this.value = value;
               this.timestamp = System.currentTimeMillis();
           }
       }
   }
   ```

3. **Use generics** for type safety and to avoid casting.
   ```java
   public class Pair<T, U> {
       private final T first;
       private final U second;
       
       public Pair(T first, U second) {
           this.first = first;
           this.second = second;
       }
       
       public T getFirst() { return first; }
       public U getSecond() { return second; }
   }
   ```

4. **Apply bounded types** to restrict generic parameters.
   ```java
   public class SortedList<T extends Comparable<T>> {
       private List<T> list = new ArrayList<>();
       
       public void add(T element) {
           list.add(element);
           Collections.sort(list);
       }
   }
   ```

5. **Wildcards** are best for method parameters requiring flexibility.
   ```java
   public class CollectionUtils {
       public static <T> void copy(List<? super T> dest, List<? extends T> src) {
           dest.addAll(src);
       }
   }
   ```

6. **Use type parameters** in method signatures when needed.
   ```java
   public class ArrayUtils {
       public static <T> T[] createArray(T... elements) {
           return elements;
       }
   }
   ```

7. **Avoid raw types** in new code.
   ```java
   // Bad
   List list = new ArrayList();
   
   // Good
   List<String> list = new ArrayList<>();
   ```

8. **Use bounded wildcards** to increase API flexibility.
   ```java
   public class StreamUtils {
       public static <T> void processAll(List<? extends T> items, Consumer<? super T> processor) {
           items.forEach(processor);
       }
   }
   ```

---

### **Summary**
- **Concrete Classes**: Fully implemented, instantiable.
- **Abstract Classes**: Partial implementation, cannot be instantiated.
- **Nested Classes**: Improve encapsulation (static, inner, local, anonymous).
- **Generics**: Type-safe reusable code (`<T>`, bounded types, wildcards).
- **Type Erasure**: Generics are removed at runtime for backward compatibility.

This detailed breakdown covers all concepts from the PDF, ensuring a strong understanding of Java classes and generics. ðŸš€