# Java Wildcards: `? extends` vs `? super`

## ğŸ¯ Overview

Java wildcards are powerful tools for creating flexible generic collections. The two main types are:
- **`? extends T`** (Upper-bounded wildcard) - "Read from collections"
- **`? super T`** (Lower-bounded wildcard) - "Write to collections"

This guide explains when and why to use each type.

---

## ğŸ“– Table of Contents
1. [Quick Comparison](#quick-comparison)
2. [Upper-bounded Wildcards (`? extends`)](#upper-bounded-wildcards--extends)
3. [Lower-bounded Wildcards (`? super`)](#lower-bounded-wildcards--super)
4. [Memory Tricks](#memory-tricks)
5. [Practical Examples](#practical-examples)
6. [Common Pitfalls](#common-pitfalls)
7. [Key Takeaways](#key-takeaways)

---

## ğŸ” Quick Comparison

| Wildcard Type | Syntax | Can Read? | Can Write? | Use Case |
|---------------|--------|-----------|------------|----------|
| **Upper-bounded** | `? extends Animal` | âœ… Yes | âŒ No | Reading/consuming data |
| **Lower-bounded** | `? super Animal` | âš ï¸ Limited | âœ… Yes | Writing/producing data |

---

## ğŸ”¼ Upper-bounded Wildcards (`? extends`)

### What does `List<? extends Animal>` mean?

> **"This list contains some unknown type that extends Animal"**

```java
// These are all valid assignments:
List<? extends Animal> list1 = new ArrayList<Animal>();
List<? extends Animal> list2 = new ArrayList<Dog>();
List<? extends Animal> list3 = new ArrayList<Cat>();
List<? extends Animal> list4 = new ArrayList<Bird>();
```

### Why can't you add elements?

**Problem:** The compiler doesn't know the exact type!

```java
List<? extends Animal> animals = new ArrayList<Dog>();

// âŒ These will NOT compile:
animals.add(new Dog());    // What if it's actually List<Cat>?
animals.add(new Cat());    // What if it's actually List<Dog>?
animals.add(new Animal()); // What if it's actually List<Dog>?

// âœ… This works (reading):
Animal animal = animals.get(0); // Safe - whatever it is, it's an Animal
```

### Visual Example

```
List<? extends Animal> could be:
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚ List<Dog>   â”‚ â† Can't add Cat here!
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         OR
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚ List<Cat>   â”‚ â† Can't add Dog here!
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         OR
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚ List<Bird>  â”‚ â† Can't add Dog or Cat here!
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### When to use `? extends`

**Perfect for:** Methods that **consume/read** from collections

```java
// Good example: Calculate total age of all animals
public static int calculateTotalAge(List<? extends Animal> animals) {
    int total = 0;
    for (Animal animal : animals) {  // âœ… Safe to read as Animal
        total += animal.getAge();
    }
    return total;
}

// This method can work with ANY animal list:
calculateTotalAge(dogList);
calculateTotalAge(catList);
calculateTotalAge(birdList);
```

---

## ğŸ”½ Lower-bounded Wildcards (`? super`)

### What does `List<? super Animal>` mean?

> **"This list contains some unknown type that is Animal or a superclass of Animal"**

```java
// These are valid assignments:
List<? super Animal> list1 = new ArrayList<Animal>();
List<? super Animal> list2 = new ArrayList<Object>();
// But NOT: List<? super Animal> list3 = new ArrayList<Dog>(); âŒ
```

### Why can you add elements?

**Reasoning:** Whatever the list type is, it can definitely hold Animal and its subtypes!

```java
List<? super Animal> animals = new ArrayList<Object>();

// âœ… These work (writing):
animals.add(new Dog());    // Dog is an Animal, Object can hold it
animals.add(new Cat());    // Cat is an Animal, Object can hold it
animals.add(new Animal()); // Animal can be held by Object

// âš ï¸ Reading is limited:
Object obj = animals.get(0); // Can only guarantee Object type
// Animal animal = animals.get(0); // âŒ Won't compile
```

### Visual Example

```
List<? super Animal> could be:
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚ List<Object>    â”‚ â† Can hold ANY Animal subtype
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
           OR
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚ List<Animal>    â”‚ â† Can hold Dog, Cat, Bird, etc.
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

All Animal subtypes fit in both cases! âœ…
```

### When to use `? super`

**Perfect for:** Methods that **produce/write** to collections

```java
// Good example: Add animals to a collection
public static void addAnimalsToShelter(List<? super Animal> shelter) {
    shelter.add(new Dog("Buddy"));     // âœ… Works
    shelter.add(new Cat("Whiskers"));  // âœ… Works
    shelter.add(new Bird("Tweety"));   // âœ… Works
}

// This method can add to ANY suitable list:
List<Animal> animalList = new ArrayList<>();
List<Object> objectList = new ArrayList<>();
addAnimalsToShelter(animalList); // âœ… Works
addAnimalsToShelter(objectList); // âœ… Works
```

---

## ğŸ§  Memory Tricks

### **PECS Principle**
> **"Producer Extends, Consumer Super"**

- **Producer** (gives you data) â†’ use `extends`
- **Consumer** (takes your data) â†’ use `super`

### **Simple Rules**
- Want to **READ** from collection? Use `extends`
- Want to **WRITE** to collection? Use `super`
- Want to do **BOTH**? Don't use wildcards!

---

## ğŸ’¼ Practical Examples

### Example 1: Copying Collections

```java
// Method that copies from source to destination
public static <T> void copy(
    List<? super T> dest,    // Writing to dest - use super
    List<? extends T> src    // Reading from src - use extends
) {
    for (T item : src) {
        dest.add(item);
    }
}

// Usage:
List<Dog> dogs = Arrays.asList(new Dog("Rex"), new Dog("Max"));
List<Animal> animals = new ArrayList<>();
copy(animals, dogs); // âœ… Works perfectly!
```

### Example 2: Utility Methods

```java
public class AnimalUtils {
    
    // Reading operation - use extends
    public static void printAllAnimals(List<? extends Animal> animals) {
        for (Animal animal : animals) {
            System.out.println(animal.getName());
        }
    }
    
    // Writing operation - use super
    public static void addRandomAnimals(List<? super Animal> list) {
        list.add(new Dog("Random Dog"));
        list.add(new Cat("Random Cat"));
    }
}
```

---

## âš ï¸ Common Pitfalls

### Pitfall 1: Trying to add to `? extends`

```java
List<? extends Animal> animals = new ArrayList<Dog>();
// animals.add(new Dog()); // âŒ Compile error!
```

**Fix:** Use `? super` if you need to add elements.

### Pitfall 2: Expecting specific types from `? super`

```java
List<? super Animal> animals = new ArrayList<Object>();
animals.add(new Dog());
// Dog dog = animals.get(0); // âŒ Compile error!
Object obj = animals.get(0); // âœ… Only Object is guaranteed
```

**Fix:** Cast if needed, or use unbounded generics.

---

## ğŸ¯ Key Takeaways

### Quick Decision Guide

**Ask yourself:**
1. **Do I need to READ from this collection?** â†’ Use `? extends`
2. **Do I need to WRITE to this collection?** â†’ Use `? super`
3. **Do I need to do BOTH?** â†’ Use regular generics (`List<Animal>`)

### The Golden Rules

| Operation | Wildcard | Reason |
|-----------|----------|---------|
| **Reading only** | `? extends T` | Guarantees all elements are T or subtype |
| **Writing only** | `? super T` | Guarantees list can accept T and subtypes |
| **Both read & write** | `T` | Need specific type, no wildcards |

### Final Summary

- **`? extends Animal`**:
  - ğŸ“– **"Read-only"** - Safe for consuming data
  - âŒ **Cannot add** - Exact type unknown
  - âœ… **Can read** - Everything is at least an Animal

- **`? super Animal`**:
  - âœï¸ **"Write-friendly"** - Safe for producing data
  - âœ… **Can add** - List accepts Animal and subtypes
  - âš ï¸ **Limited reading** - Can only guarantee Object type

Remember: **Wildcards make your code more flexible but with trade-offs!**