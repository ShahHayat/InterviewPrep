# Comprehensive Guide to Java Functional Interfaces

## Table of Contents
1. [What is a Functional Interface?](#1-what-is-a-functional-interface)
2. [What is a Lambda Function?](#2-what-is-a-lambda-function)
3. [Using Functional Interfaces with Lambda Expressions](#3-using-functional-interfaces-with-lambda-expressions)
4. [Types of Built-in Functional Interfaces](#4-types-of-built-in-functional-interfaces)
5. [Inheritance and Extension Scenarios](#5-inheritance-and-extension-scenarios)

---

## 1. What is a Functional Interface?

### 1.1 Definition and Core Concepts

A **functional interface** is an interface that contains **exactly one abstract method**. This single abstract method represents the functional contract that can be implemented using lambda expressions, method references, or anonymous classes.

#### Key Characteristics:
- **Exactly one abstract method** (SAM - Single Abstract Method)
- **Can have multiple default methods**
- **Can have multiple static methods**
- **Can have methods inherited from Object class**
- **Must be annotated with `@FunctionalInterface`** (recommended but not required)

#### Basic Example:
```java
@FunctionalInterface
public interface Calculator {
    // Single abstract method
    double calculate(double a, double b);
    
    // Default methods are allowed
    default double add(double a, double b) {
        return a + b;
    }
    
    default double subtract(double a, double b) {
        return a - b;
    }
    
    // Static methods are allowed
    static double multiply(double a, double b) {
        return a * b;
    }
    
    static double divide(double a, double b) {
        if (b == 0) {
            throw new IllegalArgumentException("Division by zero");
        }
        return a / b;
    }
    
    // Object methods don't count toward the abstract method count
    @Override
    boolean equals(Object obj);
    
    @Override
    int hashCode();
    
    @Override
    String toString();
}
```

### 1.2 The @FunctionalInterface Annotation

#### Purpose and Benefits:
```java
@FunctionalInterface
public interface DataProcessor<T> {
    void process(T data);
    
    // This would cause a compilation error if uncommented:
    // void anotherMethod(); // ERROR: Multiple abstract methods
}
```

The `@FunctionalInterface` annotation:
- **Compile-time checking**: Ensures the interface has exactly one abstract method
- **Documentation**: Clearly indicates the interface's purpose
- **IDE support**: Better tooling and autocomplete
- **Prevents accidental violations**: Compilation error if multiple abstract methods are added

#### Compilation Examples:
```java
// VALID - Single abstract method
@FunctionalInterface
public interface Validator<T> {
    boolean validate(T item);
    
    default boolean validateNotNull(T item) {
        return item != null && validate(item);
    }
}

// INVALID - Multiple abstract methods
/*
@FunctionalInterface  // Compilation error
public interface InvalidInterface {
    void method1();
    void method2(); // ERROR: Second abstract method
}
*/

// VALID - Methods from Object don't count
@FunctionalInterface
public interface StringProcessor {
    String process(String input);
    
    // These don't count as abstract methods
    boolean equals(Object obj);
    int hashCode();
    String toString();
}
```

### 1.3 Historical Context and Evolution

#### Before Java 8 (Traditional Approach):
```java
// Anonymous class implementation
Runnable task = new Runnable() {
    @Override
    public void run() {
        System.out.println("Task executed");
    }
};

// Comparator with anonymous class
Comparator<String> comparator = new Comparator<String>() {
    @Override
    public int compare(String s1, String s2) {
        return s1.compareToIgnoreCase(s2);
    }
};

List<String> names = Arrays.asList("John", "jane", "Bob");
Collections.sort(names, comparator);
```

#### Java 8 and Beyond (Functional Approach):
```java
// Lambda expression
Runnable task = () -> System.out.println("Task executed");

// Method reference
Comparator<String> comparator = String::compareToIgnoreCase;

// Lambda with comparison
List<String> names = Arrays.asList("John", "jane", "Bob");
names.sort((s1, s2) -> s1.compareToIgnoreCase(s2));

// Even more concise with method reference
names.sort(String::compareToIgnoreCase);
```

### 1.4 Real-World Functional Interface Examples

#### File Processing Interface:
```java
@FunctionalInterface
public interface FileProcessor {
    ProcessingResult process(File file) throws IOException;
    
    // Default methods for common operations
    default ProcessingResult processIfExists(File file) {
        if (file == null || !file.exists()) {
            return ProcessingResult.failure("File does not exist");
        }
        
        try {
            return process(file);
        } catch (IOException e) {
            return ProcessingResult.failure("Error processing file: " + e.getMessage());
        }
    }
    
    default ProcessingResult processWithBackup(File file, File backupDir) {
        try {
            // Create backup
            File backup = new File(backupDir, file.getName() + ".backup");
            Files.copy(file.toPath(), backup.toPath(), StandardCopyOption.REPLACE_EXISTING);
            
            // Process original
            ProcessingResult result = process(file);
            
            // If processing failed, restore from backup
            if (!result.isSuccess()) {
                Files.copy(backup.toPath(), file.toPath(), StandardCopyOption.REPLACE_EXISTING);
            }
            
            return result;
        } catch (IOException e) {
            return ProcessingResult.failure("Backup/restore failed: " + e.getMessage());
        }
    }
    
    // Static factory methods
    static FileProcessor textFileProcessor() {
        return file -> {
            List<String> lines = Files.readAllLines(file.toPath());
            // Process text content
            return ProcessingResult.success("Processed " + lines.size() + " lines");
        };
    }
    
    static FileProcessor imageFileProcessor() {
        return file -> {
            BufferedImage image = ImageIO.read(file);
            if (image == null) {
                return ProcessingResult.failure("Not a valid image file");
            }
            // Process image
            return ProcessingResult.success("Processed image: " + image.getWidth() + "x" + image.getHeight());
        };
    }
}

// Usage examples
public class FileProcessingExample {
    public void demonstrateFileProcessing() {
        // Using lambda expression
        FileProcessor csvProcessor = file -> {
            List<String> lines = Files.readAllLines(file.toPath());
            long recordCount = lines.stream()
                                   .skip(1) // Skip header
                                   .filter(line -> !line.trim().isEmpty())
                                   .count();
            return ProcessingResult.success("Processed " + recordCount + " CSV records");
        };
        
        // Using method reference
        FileProcessor simpleProcessor = this::processFileContent;
        
        // Using static factory
        FileProcessor textProcessor = FileProcessor.textFileProcessor();
        
        // Process files
        File csvFile = new File("data.csv");
        File textFile = new File("document.txt");
        File imageFile = new File("photo.jpg");
        
        ProcessingResult csvResult = csvProcessor.processIfExists(csvFile);
        ProcessingResult textResult = textProcessor.processWithBackup(textFile, new File("backup"));
        ProcessingResult imageResult = FileProcessor.imageFileProcessor().process(imageFile);
    }
    
    private ProcessingResult processFileContent(File file) throws IOException {
        // Simple file processing logic
        long size = Files.size(file.toPath());
        return ProcessingResult.success("File size: " + size + " bytes");
    }
}
```

#### Event Handler Interface:
```java
@FunctionalInterface
public interface EventHandler<T> {
    void handle(T event);
    
    // Default methods for event processing patterns
    default EventHandler<T> andThen(EventHandler<T> after) {
        return event -> {
            handle(event);
            after.handle(event);
        };
    }
    
    default EventHandler<T> filter(Predicate<T> condition) {
        return event -> {
            if (condition.test(event)) {
                handle(event);
            }
        };
    }
    
    default EventHandler<T> withLogging() {
        return event -> {
            System.out.println("Handling event: " + event);
            handle(event);
            System.out.println("Event handled successfully");
        };
    }
    
    default EventHandler<T> withErrorHandling() {
        return event -> {
            try {
                handle(event);
            } catch (Exception e) {
                System.err.println("Error handling event " + event + ": " + e.getMessage());
            }
        };
    }
    
    // Static utility methods
    static <T> EventHandler<T> noOp() {
        return event -> { /* Do nothing */ };
    }
    
    static <T> EventHandler<T> logging() {
        return event -> System.out.println("Event received: " + event);
    }
    
    static <T> EventHandler<T> compose(EventHandler<T>... handlers) {
        return event -> {
            for (EventHandler<T> handler : handlers) {
                handler.handle(event);
            }
        };
    }
}

// Usage in event-driven system
public class EventDrivenExample {
    public void demonstrateEventHandling() {
        // Simple event handlers
        EventHandler<String> logger = EventHandler.logging();
        EventHandler<String> emailNotifier = message -> sendEmail("admin@example.com", message);
        EventHandler<String> slackNotifier = message -> sendSlackMessage("#alerts", message);
        
        // Composed event handlers
        EventHandler<String> errorHandler = logger
            .andThen(emailNotifier)
            .andThen(slackNotifier)
            .withErrorHandling();
        
        EventHandler<String> warningHandler = logger
            .filter(message -> message.contains("WARNING"))
            .andThen(slackNotifier);
        
        EventHandler<String> infoHandler = EventHandler.compose(
            logger,
            message -> logToFile(message)
        );
        
        // Handle different types of events
        errorHandler.handle("ERROR: Database connection failed");
        warningHandler.handle("WARNING: High memory usage detected");
        infoHandler.handle("INFO: User login successful");
    }
    
    private void sendEmail(String recipient, String message) {
        System.out.println("Email sent to " + recipient + ": " + message);
    }
    
    private void sendSlackMessage(String channel, String message) {
        System.out.println("Slack message sent to " + channel + ": " + message);
    }
    
    private void logToFile(String message) {
        System.out.println("Logged to file: " + message);
    }
}
```

### 1.5 Memory and Performance Implications

#### Memory Usage Comparison:
```java
public class MemoryComparisonExample {
    
    // Traditional anonymous class approach
    public void traditionalApproach() {
        List<String> items = Arrays.asList("apple", "banana", "cherry");
        
        // Each anonymous class creates a new .class file
        items.forEach(new Consumer<String>() {
            @Override
            public void accept(String item) {
                System.out.println(item.toUpperCase());
            }
        });
    }
    
    // Lambda expression approach
    public void lambdaApproach() {
        List<String> items = Arrays.asList("apple", "banana", "cherry");
        
        // Lambda expressions are more memory efficient
        // They use invokedynamic for better performance
        items.forEach(item -> System.out.println(item.toUpperCase()));
        
        // Method reference is even more efficient
        items.forEach(System.out::println);
    }
    
    // Performance test example
    public void performanceComparison() {
        List<Integer> numbers = IntStream.range(1, 1_000_000)
                                        .boxed()
                                        .collect(Collectors.toList());
        
        // Traditional approach timing
        long start = System.nanoTime();
        numbers.stream()
               .filter(new Predicate<Integer>() {
                   @Override
                   public boolean test(Integer n) {
                       return n % 2 == 0;
                   }
               })
               .mapToInt(Integer::intValue)
               .sum();
        long traditionalTime = System.nanoTime() - start;
        
        // Lambda approach timing
        start = System.nanoTime();
        numbers.stream()
               .filter(n -> n % 2 == 0)
               .mapToInt(Integer::intValue)
               .sum();
        long lambdaTime = System.nanoTime() - start;
        
        System.out.println("Traditional time: " + traditionalTime + " ns");
        System.out.println("Lambda time: " + lambdaTime + " ns");
        System.out.println("Performance improvement: " + 
                          ((double)(traditionalTime - lambdaTime) / traditionalTime * 100) + "%");
    }
}

```

## 2. What is a Lambda Function?

### 2.1 Definition and Fundamental Concepts

A **lambda function** (or lambda expression) is an anonymous function that can be created without belonging to any class. It provides a clear and concise way to represent one method interface using an expression. Lambda expressions enable you to treat functionality as a method argument, or code as data.

#### Mathematical Foundation:
Lambda expressions are based on **lambda calculus**, a formal system in mathematical logic for expressing computation based on function abstraction and application.

```
Mathematical notation: λx.x + 1
Java equivalent:       x -> x + 1
```

#### Core Characteristics:
- **Anonymous**: No name, defined inline
- **Function**: Not associated with a particular class
- **Passed around**: Can be passed as argument or stored in variables
- **Concise**: Less boilerplate than anonymous classes

### 2.2 Lambda Expression Syntax

#### Basic Syntax Structure:
```
(parameters) -> { body }
```

#### Syntax Variations:

##### 1. No Parameters:
```java
// Empty parameter list
() -> System.out.println("Hello World")
() -> { return 42; }
() -> 42  // Single expression, return is implicit

// Real-world examples
Runnable task = () -> System.out.println("Task executed");
Supplier<String> timestampSupplier = () -> LocalDateTime.now().toString();
Supplier<Random> randomSupplier = () -> new Random();
```

##### 2. Single Parameter:
```java
// Single parameter - parentheses optional
x -> x * 2
(x) -> x * 2  // Parentheses optional but can be used for clarity
x -> { return x * 2; }  // Block body

// Real-world examples
Function<String, Integer> lengthCalculator = s -> s.length();
Function<String, String> upperCase = s -> s.toUpperCase();
Consumer<String> printer = s -> System.out.println(s);
Predicate<String> notEmpty = s -> !s.isEmpty();
```

##### 3. Multiple Parameters:
```java
// Multiple parameters - parentheses required
(a, b) -> a + b
(a, b) -> { return a + b; }
(String a, String b) -> a.concat(b)  // Explicit types optional

// Real-world examples
BinaryOperator<Integer> adder = (a, b) -> a + b;
BiFunction<String, String, String> concatenator = (a, b) -> a + " " + b;
Comparator<String> lengthComparator = (s1, s2) -> s1.length() - s2.length();
```

### 2.3 Method References

Method references are a shorthand notation for lambda expressions that call a specific method.

#### Types of Method References:

##### 1. Static Method References:
```java
// Lambda expression
Function<String, Integer> parser1 = s -> Integer.parseInt(s);

// Method reference (more concise)
Function<String, Integer> parser2 = Integer::parseInt;

// More examples
Function<Double, Double> sqrt = Math::sqrt;
BiFunction<Double, Double, Double> pow = Math::pow;
```

##### 2. Instance Method References:
```java
// Instance method on particular object
List<String> names = Arrays.asList("Alice", "bob", "CHARLIE");
names.forEach(System.out::println);

// Instance method on arbitrary object
names.sort(String::compareToIgnoreCase);
```

##### 3. Constructor References:
```java
// No-argument constructor
Supplier<ArrayList<String>> listSupplier = ArrayList::new;

// Single argument constructor
Function<String, StringBuilder> sbCreator = StringBuilder::new;

// Array constructor
Function<Integer, int[]> arrayCreator = int[]::new;
```

### 2.4 Variable Capture and Scope

#### Effectively Final Variables:
```java
public void demonstrateVariableCapture() {
    int multiplier = 10;  // Effectively final
    String prefix = "Result: ";  // Effectively final
    
    Function<Integer, String> calculator = x -> 
        prefix + (x * multiplier);  // Captures local variables
    
    System.out.println(calculator.apply(5));  // Output: Result: 50
    
    // This would cause compilation error:
    // multiplier = 20;  // ERROR: Variable must be effectively final
}
```

## 3. Using Functional Interfaces with Lambda Expressions

### 3.1 Basic Usage Patterns

#### Simple Function Application:
```java
public class BasicLambdaUsage {
    
    public void demonstrateBasicUsage() {
        // Function interface - transforms input to output
        Function<String, String> upperCaseFunction = s -> s.toUpperCase();
        String result = upperCaseFunction.apply("hello world");
        System.out.println(result); // HELLO WORLD
        
        // Consumer interface - consumes input, returns nothing
        Consumer<String> printer = s -> System.out.println("Processing: " + s);
        printer.accept("Important Data");
        
        // Supplier interface - supplies a value
        Supplier<LocalDateTime> timeSupplier = () -> LocalDateTime.now();
        LocalDateTime currentTime = timeSupplier.get();
        
        // Predicate interface - tests a condition
        Predicate<Integer> isEven = n -> n % 2 == 0;
        boolean result2 = isEven.test(10); // true
    }
}
```

#### Chaining Operations:
```java
public class OperationChaining {
    
    public void demonstrateChaining() {
        List<String> words = Arrays.asList("apple", "banana", "cherry", "date");
        
        // Chain multiple operations
        List<String> result = words.stream()
            .filter(s -> s.length() > 4)        // Predicate
            .map(s -> s.toUpperCase())          // Function
            .peek(s -> System.out.println("Processing: " + s))  // Consumer
            .collect(Collectors.toList());
        
        // Function composition
        Function<String, String> trim = String::trim;
        Function<String, String> upperCase = String::toUpperCase;
        Function<String, Integer> length = String::length;
        
        Function<String, Integer> pipeline = trim
            .andThen(upperCase)
            .andThen(length);
        
        int resultLength = pipeline.apply("  hello world  ");
        System.out.println("Result length: " + resultLength); // 11
    }
}
```

### 3.2 Advanced Usage Patterns

#### Custom Functional Interfaces:
```java
@FunctionalInterface
public interface DataProcessor<T, R> {
    R process(T input) throws Exception;
    
    // Default method for safe processing
    default R processSafely(T input, R defaultValue) {
        try {
            return process(input);
        } catch (Exception e) {
            System.err.println("Processing failed: " + e.getMessage());
            return defaultValue;
        }
    }
    
    // Default method for chaining
    default <V> DataProcessor<T, V> andThen(DataProcessor<R, V> after) {
        return input -> after.process(process(input));
    }
}

// Usage example
public class CustomFunctionalInterfaceUsage {
    
    public void demonstrateCustomInterface() {
        // JSON processor
        DataProcessor<String, Map<String, Object>> jsonProcessor = jsonStr -> {
            // Simulate JSON parsing
            Map<String, Object> result = new HashMap<>();
            result.put("data", jsonStr);
            result.put("timestamp", System.currentTimeMillis());
            return result;
        };
        
        // XML processor
        DataProcessor<Map<String, Object>, String> xmlProcessor = map -> {
            StringBuilder xml = new StringBuilder("<root>");
            map.forEach((key, value) -> 
                xml.append("<").append(key).append(">")
                   .append(value)
                   .append("</").append(key).append(">"));
            xml.append("</root>");
            return xml.toString();
        };
        
        // Chain processors
        DataProcessor<String, String> jsonToXml = jsonProcessor.andThen(xmlProcessor);
        
        String input = "{\"name\":\"John\", \"age\":30}";
        String xmlResult = jsonToXml.processSafely(input, "<error/>");
        System.out.println("XML Result: " + xmlResult);
    }
}
```

#### Exception Handling in Lambdas:
```java
public class ExceptionHandlingInLambdas {
    
    // Wrapper interface for checked exceptions
    @FunctionalInterface
    public interface ThrowingFunction<T, R> {
        R apply(T t) throws Exception;
        
        static <T, R> Function<T, R> unchecked(ThrowingFunction<T, R> f) {
            return t -> {
                try {
                    return f.apply(t);
                } catch (Exception e) {
                    throw new RuntimeException(e);
                }
            };
        }
        
        static <T, R> Function<T, Optional<R>> safe(ThrowingFunction<T, R> f) {
            return t -> {
                try {
                    return Optional.of(f.apply(t));
                } catch (Exception e) {
                    return Optional.empty();
                }
            };
        }
    }
    
    public void demonstrateExceptionHandling() {
        List<String> numbers = Arrays.asList("1", "2", "abc", "4", "xyz");
        
        // Traditional approach with try-catch in lambda
        List<Integer> parsed1 = numbers.stream()
            .map(s -> {
                try {
                    return Integer.parseInt(s);
                } catch (NumberFormatException e) {
                    return 0; // Default value
                }
            })
            .collect(Collectors.toList());
        
        // Using unchecked wrapper
        List<Integer> parsed2 = numbers.stream()
            .map(ThrowingFunction.unchecked(Integer::parseInt))
            .collect(Collectors.toList());
        
        // Using safe wrapper
        List<Integer> parsed3 = numbers.stream()
            .map(ThrowingFunction.safe(Integer::parseInt))
            .filter(Optional::isPresent)
            .map(Optional::get)
            .collect(Collectors.toList());
        
        System.out.println("Parsed with defaults: " + parsed1);
        System.out.println("Parsed safely: " + parsed3);
    }
}
```

### 3.3 Real-World Application Examples

#### Event Processing System:
```java
public class EventProcessingSystem {
    
    @FunctionalInterface
    public interface EventHandler<T> {
        void handle(T event);
        
        default EventHandler<T> andThen(EventHandler<T> after) {
            return event -> {
                handle(event);
                after.handle(event);
            };
        }
        
        default EventHandler<T> filter(Predicate<T> condition) {
            return event -> {
                if (condition.test(event)) {
                    handle(event);
                }
            };
        }
    }
    
    public void setupEventHandlers() {
        // Email notification handler
        EventHandler<String> emailHandler = message -> 
            System.out.println("Email sent: " + message);
        
        // SMS notification handler
        EventHandler<String> smsHandler = message -> 
            System.out.println("SMS sent: " + message);
        
        // Logging handler
        EventHandler<String> logHandler = message -> 
            System.out.println("Logged: " + message);
        
        // Composite handler for critical events
        EventHandler<String> criticalHandler = emailHandler
            .andThen(smsHandler)
            .andThen(logHandler);
        
        // Filtered handler for warnings
        EventHandler<String> warningHandler = logHandler
            .filter(msg -> msg.contains("WARNING"));
        
        // Simulate events
        criticalHandler.handle("CRITICAL: System down!");
        warningHandler.handle("WARNING: High memory usage");
        warningHandler.handle("INFO: User logged in"); // Filtered out
    }
}
```

#### Data Validation Framework:
```java
public class ValidationFramework {
    
    @FunctionalInterface
    public interface Validator<T> {
        ValidationResult validate(T object);
        
        default Validator<T> and(Validator<T> other) {
            return object -> {
                ValidationResult result1 = validate(object);
                if (!result1.isValid()) {
                    return result1;
                }
                return other.validate(object);
            };
        }
        
        static <T> Validator<T> of(Predicate<T> predicate, String errorMessage) {
            return object -> predicate.test(object) 
                ? ValidationResult.valid() 
                : ValidationResult.invalid(errorMessage);
        }
    }
    
    public void demonstrateValidation() {
        // Individual validators
        Validator<String> notNull = Validator.of(
            Objects::nonNull, 
            "Value cannot be null"
        );
        
        Validator<String> notEmpty = Validator.of(
            s -> !s.isEmpty(), 
            "Value cannot be empty"
        );
        
        Validator<String> maxLength = Validator.of(
            s -> s.length() <= 50, 
            "Value cannot exceed 50 characters"
        );
        
        Validator<String> emailFormat = Validator.of(
            s -> s.matches("^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$"),
            "Invalid email format"
        );
        
        // Composite validator
        Validator<String> emailValidator = notNull
            .and(notEmpty)
            .and(maxLength)
            .and(emailFormat);
        
        // Test validation
        List<String> emails = Arrays.asList(
            "valid@example.com",
            null,
            "",
            "invalid-email",
            "way.too.long.email.address.that.exceeds.fifty.characters@example.com"
        );
        
        emails.forEach(email -> {
            ValidationResult result = emailValidator.validate(email);
            System.out.println(email + " -> " + 
                (result.isValid() ? "VALID" : "INVALID: " + result.getErrorMessage()));
        });
    }
}

class ValidationResult {
    private final boolean valid;
    private final String errorMessage;
    
    private ValidationResult(boolean valid, String errorMessage) {
        this.valid = valid;
        this.errorMessage = errorMessage;
    }
    
    public static ValidationResult valid() {
        return new ValidationResult(true, null);
    }
    
    public static ValidationResult invalid(String errorMessage) {
        return new ValidationResult(false, errorMessage);
    }
    
    public boolean isValid() { return valid; }
    public String getErrorMessage() { return errorMessage; }
}
```

## 4. Types of Built-in Functional Interfaces

Java 8 introduced a comprehensive set of built-in functional interfaces in the `java.util.function` package. These interfaces cover the most common patterns of functional programming and provide a solid foundation for lambda expressions.

### 4.1 Consumer<T> - The Data Consumer

The `Consumer<T>` interface represents an operation that accepts a single input argument and returns no result. It's designed for side effects like printing, logging, or modifying external state.

#### Interface Definition:
```java
@FunctionalInterface
public interface Consumer<T> {
    void accept(T t);
    
    default Consumer<T> andThen(Consumer<? super T> after) {
        Objects.requireNonNull(after);
        return (T t) -> { accept(t); after.accept(t); };
    }
}
```

#### Basic Usage Examples:
```java
public class ConsumerExamples {
    
    public void basicConsumerUsage() {
        // Simple consumer
        Consumer<String> printer = s -> System.out.println(s);
        printer.accept("Hello World");
        
        // Method reference
        Consumer<String> println = System.out::println;
        println.accept("Hello with method reference");
        
        // Complex consumer
        Consumer<Person> personProcessor = person -> {
            System.out.println("Processing person: " + person.getName());
            person.setLastProcessed(LocalDateTime.now());
            System.out.println("Processed at: " + person.getLastProcessed());
        };
        
        Person person = new Person("Alice", 30);
        personProcessor.accept(person);
    }
    
    public void demonstrateConsumerChaining() {
        // Individual consumers
        Consumer<String> upperCase = s -> System.out.println(s.toUpperCase());
        Consumer<String> addPrefix = s -> System.out.println(">>> " + s);
        Consumer<String> addSuffix = s -> System.out.println(s + " <<<");
        
        // Chain consumers
        Consumer<String> chainedConsumer = upperCase
            .andThen(addPrefix)
            .andThen(addSuffix);
        
        chainedConsumer.accept("hello world");
        // Output:
        // HELLO WORLD
        // >>> hello world
        // hello world <<<
        
        // Real-world example: Multiple notification systems
        Consumer<String> emailNotifier = message -> sendEmail(message);
        Consumer<String> smsNotifier = message -> sendSMS(message);
        Consumer<String> slackNotifier = message -> sendSlackMessage(message);
        
        Consumer<String> criticalAlertHandler = emailNotifier
            .andThen(smsNotifier)
            .andThen(slackNotifier);
        
        criticalAlertHandler.accept("CRITICAL: Database is down!");
    }
    
    private void sendEmail(String message) {
        System.out.println("Email sent: " + message);
    }
    
    private void sendSMS(String message) {
        System.out.println("SMS sent: " + message);
    }
    
    private void sendSlackMessage(String message) {
        System.out.println("Slack message sent: " + message);
    }
}
```

#### Consumer Variants:
```java
public class ConsumerVariants {
    
    public void demonstrateConsumerVariants() {
        // BiConsumer - accepts two arguments
        BiConsumer<String, Integer> keyValueProcessor = (key, value) -> 
            System.out.println(key + " = " + value);
        keyValueProcessor.accept("age", 30);
        
        // IntConsumer - specialized for int
        IntConsumer intProcessor = value -> System.out.println("Processing int: " + value);
        intProcessor.accept(42);
        
        // LongConsumer - specialized for long
        LongConsumer longProcessor = value -> System.out.println("Processing long: " + value);
        longProcessor.accept(123456789L);
        
        // DoubleConsumer - specialized for double
        DoubleConsumer doubleProcessor = value -> System.out.println("Processing double: " + value);
        doubleProcessor.accept(3.14159);
        
        // ObjIntConsumer - accepts object and int
        ObjIntConsumer<String> stringIntProcessor = (str, num) -> 
            System.out.println(str + " repeated " + num + " times: " + str.repeat(num));
        stringIntProcessor.accept("Hello", 3);
        
        // ObjLongConsumer - accepts object and long
        ObjLongConsumer<String> stringLongProcessor = (str, timestamp) -> 
            System.out.println(str + " at timestamp: " + timestamp);
        stringLongProcessor.accept("Event", System.currentTimeMillis());
        
        // ObjDoubleConsumer - accepts object and double
        ObjDoubleConsumer<String> stringDoubleProcessor = (str, price) -> 
            System.out.println(str + " costs $" + String.format("%.2f", price));
        stringDoubleProcessor.accept("Coffee", 4.99);
    }
}
```

#### Advanced Consumer Patterns:
```java
public class AdvancedConsumerPatterns {
    
    // Conditional consumer
    public static <T> Consumer<T> conditionalConsumer(Predicate<T> condition, Consumer<T> consumer) {
        return item -> {
            if (condition.test(item)) {
                consumer.accept(item);
            }
        };
    }
    
    // Logging consumer wrapper
    public static <T> Consumer<T> withLogging(Consumer<T> consumer, String operation) {
        return item -> {
            System.out.println("Starting " + operation + " for: " + item);
            try {
                consumer.accept(item);
                System.out.println("Completed " + operation + " for: " + item);
            } catch (Exception e) {
                System.err.println("Failed " + operation + " for: " + item + " - " + e.getMessage());
            }
        };
    }
    
    // Batch consumer
    public static <T> Consumer<List<T>> batchConsumer(Consumer<T> itemConsumer, int batchSize) {
        return list -> {
            for (int i = 0; i < list.size(); i += batchSize) {
                List<T> batch = list.subList(i, Math.min(i + batchSize, list.size()));
                System.out.println("Processing batch " + (i / batchSize + 1) + " of size " + batch.size());
                batch.forEach(itemConsumer);
            }
        };
    }
    
    public void demonstrateAdvancedPatterns() {
        List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);
        
        // Conditional processing
        Consumer<Integer> evenProcessor = conditionalConsumer(
            n -> n % 2 == 0,
            n -> System.out.println("Even number: " + n)
        );
        numbers.forEach(evenProcessor);
        
        // Logging wrapper
        Consumer<Integer> squareCalculator = n -> System.out.println(n + "² = " + (n * n));
        Consumer<Integer> loggedCalculator = withLogging(squareCalculator, "square calculation");
        loggedCalculator.accept(5);
        
        // Batch processing
        Consumer<Integer> numberProcessor = n -> System.out.println("Processing: " + n);
        Consumer<List<Integer>> batchProcessor = batchConsumer(numberProcessor, 3);
        batchProcessor.accept(numbers);
    }
}
```

### 4.2 Supplier<T> - The Data Provider

The `Supplier<T>` interface represents a supplier of results. It takes no arguments and returns a value. It's useful for lazy evaluation, factory methods, and generating data.

#### Interface Definition:
```java
@FunctionalInterface
public interface Supplier<T> {
    T get();
}
```

#### Basic Usage Examples:
```java
public class SupplierExamples {
    
    public void basicSupplierUsage() {
        // Simple supplier
        Supplier<String> stringSupplier = () -> "Hello World";
        System.out.println(stringSupplier.get());
        
        // Random number supplier
        Supplier<Integer> randomIntSupplier = () -> new Random().nextInt(100);
        System.out.println("Random number: " + randomIntSupplier.get());
        
        // Current timestamp supplier
        Supplier<String> timestampSupplier = () -> LocalDateTime.now().toString();
        System.out.println("Current time: " + timestampSupplier.get());
        
        // Method reference supplier
        Supplier<Double> randomDoubleSupplier = Math::random;
        System.out.println("Random double: " + randomDoubleSupplier.get());
        
        // Constructor reference supplier
        Supplier<ArrayList<String>> listSupplier = ArrayList::new;
        List<String> newList = listSupplier.get();
    }
    
    public void demonstrateLazyEvaluation() {
        // Expensive operation supplier
        Supplier<String> expensiveOperation = () -> {
            System.out.println("Performing expensive calculation...");
            try {
                Thread.sleep(1000); // Simulate expensive operation
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }
            return "Expensive result";
        };
        
        // Lazy evaluation - operation not performed until needed
        System.out.println("Supplier created, but operation not yet performed");
        
        // Now the operation is performed
        String result = expensiveOperation.get();
        System.out.println("Result: " + result);
        
        // Called again - operation performed again (no caching)
        String result2 = expensiveOperation.get();
        System.out.println("Result2: " + result2);
    }
}
```

#### Supplier Variants:
```java
public class SupplierVariants {
    
    public void demonstrateSupplierVariants() {
        // BooleanSupplier - supplies boolean
        BooleanSupplier coinFlip = () -> Math.random() < 0.5;
        System.out.println("Coin flip: " + (coinFlip.getAsBoolean() ? "Heads" : "Tails"));
        
        // IntSupplier - supplies int
        IntSupplier diceRoll = () -> new Random().nextInt(6) + 1;
        System.out.println("Dice roll: " + diceRoll.getAsInt());
        
        // LongSupplier - supplies long
        LongSupplier timestampSupplier = System::currentTimeMillis;
        System.out.println("Current timestamp: " + timestampSupplier.getAsLong());
        
        // DoubleSupplier - supplies double
        DoubleSupplier temperatureReading = () -> 20.0 + (Math.random() * 15.0);
        System.out.println("Temperature: " + String.format("%.1f°C", temperatureReading.getAsDouble()));
    }
}
```

#### Advanced Supplier Patterns:
```java
public class AdvancedSupplierPatterns {
    
    // Memoized supplier (caches result)
    public static <T> Supplier<T> memoize(Supplier<T> supplier) {
        return new Supplier<T>() {
            private T value;
            private boolean computed = false;
            
            @Override
            public T get() {
                if (!computed) {
                    value = supplier.get();
                    computed = true;
                }
                return value;
            }
        };
    }
    
    // Retry supplier
    public static <T> Supplier<T> withRetry(Supplier<T> supplier, int maxAttempts) {
        return () -> {
            RuntimeException lastException = null;
            for (int i = 0; i < maxAttempts; i++) {
                try {
                    return supplier.get();
                } catch (RuntimeException e) {
                    lastException = e;
                    System.out.println("Attempt " + (i + 1) + " failed: " + e.getMessage());
                }
            }
            throw new RuntimeException("All " + maxAttempts + " attempts failed", lastException);
        };
    }
    
    // Conditional supplier
    public static <T> Supplier<T> conditional(BooleanSupplier condition, Supplier<T> trueSupplier, Supplier<T> falseSupplier) {
        return () -> condition.getAsBoolean() ? trueSupplier.get() : falseSupplier.get();
    }
    
    // Sequence supplier
    public static Supplier<Integer> sequence(int start, int increment) {
        return new Supplier<Integer>() {
            private int current = start;
            
            @Override
            public Integer get() {
                int result = current;
                current += increment;
                return result;
            }
        };
    }
    
    public void demonstrateAdvancedPatterns() {
        // Memoized expensive operation
        Supplier<String> expensiveSupplier = () -> {
            System.out.println("Performing expensive operation...");
            return "Expensive Result";
        };
        Supplier<String> memoizedSupplier = memoize(expensiveSupplier);
        
        System.out.println("First call: " + memoizedSupplier.get());
        System.out.println("Second call: " + memoizedSupplier.get()); // No re-computation
        
        // Retry mechanism
        Supplier<String> unreliableSupplier = () -> {
            if (Math.random() < 0.7) {
                throw new RuntimeException("Random failure");
            }
            return "Success!";
        };
        Supplier<String> reliableSupplier = withRetry(unreliableSupplier, 3);
        System.out.println(reliableSupplier.get());
        
        // Conditional supplier
        Supplier<String> workingHours = () -> "Business hours response";
        Supplier<String> afterHours = () -> "After hours response";
        BooleanSupplier isBusinessHours = () -> {
            int hour = LocalTime.now().getHour();
            return hour >= 9 && hour < 17;
        };
        
        Supplier<String> contextualResponse = conditional(isBusinessHours, workingHours, afterHours);
        System.out.println(contextualResponse.get());
        
        // Sequence supplier
        Supplier<Integer> idGenerator = sequence(1000, 1);
        System.out.println("ID 1: " + idGenerator.get());
        System.out.println("ID 2: " + idGenerator.get());
        System.out.println("ID 3: " + idGenerator.get());
    }
}
```

### 4.3 Function<T, R> - The Data Transformer

The `Function<T, R>` interface represents a function that accepts one argument and produces a result. It's the most versatile functional interface for data transformation.

#### Interface Definition:
```java
@FunctionalInterface
public interface Function<T, R> {
    R apply(T t);
    
    default <V> Function<V, R> compose(Function<? super V, ? extends T> before) {
        Objects.requireNonNull(before);
        return (V v) -> apply(before.apply(v));
    }
    
    default <V> Function<T, V> andThen(Function<? super R, ? extends V> after) {
        Objects.requireNonNull(after);
        return (T t) -> after.apply(apply(t));
    }
    
    static <T> Function<T, T> identity() {
        return t -> t;
    }
}
```

#### Basic Usage Examples:
```java
public class FunctionExamples {
    
    public void basicFunctionUsage() {
        // Simple transformation
        Function<String, Integer> stringLength = s -> s.length();
        System.out.println("Length of 'Hello': " + stringLength.apply("Hello"));
        
        // Method reference
        Function<String, String> upperCase = String::toUpperCase;
        System.out.println("Uppercase: " + upperCase.apply("hello world"));
        
        // Complex transformation
        Function<Person, String> personSummary = person -> 
            person.getName() + " (" + person.getAge() + " years old)";
        Person person = new Person("Alice", 30);
        System.out.println(personSummary.apply(person));
        
        // Numeric transformation
        Function<Double, Double> celsiusToFahrenheit = celsius -> (celsius * 9.0 / 5.0) + 32.0;
        System.out.println("25°C = " + celsiusToFahrenheit.apply(25.0) + "°F");
    }
    
    public void demonstrateFunctionComposition() {
        // Individual functions
        Function<String, String> trim = String::trim;
        Function<String, String> upperCase = String::toUpperCase;
        Function<String, Integer> length = String::length;
        Function<Integer, String> format = n -> "Length: " + n;
        
        // Compose functions using andThen
        Function<String, String> trimAndUpper = trim.andThen(upperCase);
        Function<String, Integer> trimUpperLength = trim.andThen(upperCase).andThen(length);
        Function<String, String> fullPipeline = trim
            .andThen(upperCase)
            .andThen(length)
            .andThen(format);
        
        String input = "  hello world  ";
        System.out.println("Input: '" + input + "'");
        System.out.println("Trim and upper: '" + trimAndUpper.apply(input) + "'");
        System.out.println("Full pipeline: " + fullPipeline.apply(input));
        
        // Compose functions using compose
        Function<String, String> lengthFormatter = length.compose(upperCase).compose(trim).andThen(format);
        System.out.println("Using compose: " + lengthFormatter.apply(input));
        
        // Identity function
        Function<String, String> identity = Function.identity();
        System.out.println("Identity: " + identity.apply("test"));
    }
}
```

#### Function Variants:
```java
public class FunctionVariants {
    
    public void demonstrateFunctionVariants() {
        // BiFunction - takes two arguments
        BiFunction<String, String, String> concatenate = (a, b) -> a + " " + b;
        System.out.println(concatenate.apply("Hello", "World"));
        
        BiFunction<Integer, Integer, Integer> add = (a, b) -> a + b;
        System.out.println("5 + 3 = " + add.apply(5, 3));
        
        // UnaryOperator - Function<T, T>
        UnaryOperator<String> addPrefix = s -> "Mr. " + s;
        System.out.println(addPrefix.apply("Smith"));
        
        UnaryOperator<Integer> square = n -> n * n;
        System.out.println("5² = " + square.apply(5));
        
        // BinaryOperator - BiFunction<T, T, T>
        BinaryOperator<String> concat = (a, b) -> a + b;
        System.out.println(concat.apply("Hello", "World"));
        
        BinaryOperator<Integer> max = Integer::max;
        System.out.println("Max of 10 and 15: " + max.apply(10, 15));
        
        // Primitive specialized functions
        IntFunction<String> intToString = n -> "Number: " + n;
        System.out.println(intToString.apply(42));
        
        ToIntFunction<String> stringToInt = Integer::parseInt;
        System.out.println("Parsed: " + stringToInt.applyAsInt("123"));
        
        IntToDoubleFunction intToDouble = n -> n * 1.5;
        System.out.println("1.5 times 10: " + intToDouble.applyAsDouble(10));
        
        ToDoubleFunction<String> stringLength = s -> s.length();
        System.out.println("Length as double: " + stringLength.applyAsDouble("Hello"));
    }
}
```

#### Advanced Function Patterns:
```java
public class AdvancedFunctionPatterns {
    
    // Currying - converting a function with multiple arguments into a series of functions
    public static <A, B, C> Function<A, Function<B, C>> curry(BiFunction<A, B, C> biFunction) {
        return a -> b -> biFunction.apply(a, b);
    }
    
    // Partial application
    public static <A, B, C> Function<B, C> partial(BiFunction<A, B, C> biFunction, A a) {
        return b -> biFunction.apply(a, b);
    }
    
    // Function that handles exceptions
    public static <T, R> Function<T, Optional<R>> safe(Function<T, R> function) {
        return input -> {
            try {
                return Optional.of(function.apply(input));
            } catch (Exception e) {
                return Optional.empty();
            }
        };
    }
    
    // Function with default value
    public static <T, R> Function<T, R> withDefault(Function<T, R> function, R defaultValue) {
        return input -> {
            try {
                R result = function.apply(input);
                return result != null ? result : defaultValue;
            } catch (Exception e) {
                return defaultValue;
            }
        };
    }
    
    // Conditional function
    public static <T, R> Function<T, R> conditional(
            Predicate<T> condition, 
            Function<T, R> trueFunction, 
            Function<T, R> falseFunction) {
        return input -> condition.test(input) ? trueFunction.apply(input) : falseFunction.apply(input);
    }
    
    public void demonstrateAdvancedPatterns() {
        // Currying example
        BiFunction<Integer, Integer, Integer> add = (a, b) -> a + b;
        Function<Integer, Function<Integer, Integer>> curriedAdd = curry(add);
        Function<Integer, Integer> add5 = curriedAdd.apply(5);
        System.out.println("Curried add 5 + 3 = " + add5.apply(3));
        
        // Partial application
        BiFunction<String, String, String> greet = (greeting, name) -> greeting + ", " + name + "!";
        Function<String, String> sayHello = partial(greet, "Hello");
        Function<String, String> sayGoodbye = partial(greet, "Goodbye");
        
        System.out.println(sayHello.apply("Alice"));
        System.out.println(sayGoodbye.apply("Bob"));
        
        // Safe function (exception handling)
        Function<String, Integer> parseInt = Integer::parseInt;
        Function<String, Optional<Integer>> safeParseInt = safe(parseInt);
        
        System.out.println("Safe parse '123': " + safeParseInt.apply("123"));
        System.out.println("Safe parse 'abc': " + safeParseInt.apply("abc"));
        
        // Function with default value
        Function<String, Integer> parseIntWithDefault = withDefault(parseInt, 0);
        System.out.println("Parse with default '123': " + parseIntWithDefault.apply("123"));
        System.out.println("Parse with default 'abc': " + parseIntWithDefault.apply("abc"));
        
        // Conditional function
        Function<Integer, String> evenOddMessage = conditional(
            n -> n % 2 == 0,
            n -> n + " is even",
            n -> n + " is odd"
        );
        
        System.out.println(evenOddMessage.apply(4));
        System.out.println(evenOddMessage.apply(7));
        
        // Complex pipeline with error handling
        Function<String, Optional<Double>> processNumber = safe(Double::parseDouble)
            .andThen(opt -> opt.map(d -> d * 2))
            .andThen(opt -> opt.filter(d -> d > 10));
        
        System.out.println("Process '15': " + processNumber.apply("15")); // 30.0
        System.out.println("Process '3': " + processNumber.apply("3"));   // empty (6 <= 10)
        System.out.println("Process 'abc': " + processNumber.apply("abc")); // empty (parse error)
    }
}
```

### 4.4 Predicate<T> - The Condition Tester

The `Predicate<T>` interface represents a predicate (boolean-valued function) of one argument. It's used for filtering, validation, and conditional logic.

#### Interface Definition:
```java
@FunctionalInterface
public interface Predicate<T> {
    boolean test(T t);
    
    default Predicate<T> and(Predicate<? super T> other) {
        Objects.requireNonNull(other);
        return (t) -> test(t) && other.test(t);
    }
    
    default Predicate<T> negate() {
        return (t) -> !test(t);
    }
    
    default Predicate<T> or(Predicate<? super T> other) {
        Objects.requireNonNull(other);
        return (t) -> test(t) || other.test(t);
    }
    
    static <T> Predicate<T> isEqual(Object targetRef) {
        return (null == targetRef)
                ? Objects::isNull
                : object -> targetRef.equals(object);
    }
    
    static <T> Predicate<T> not(Predicate<? super T> target) {
        Objects.requireNonNull(target);
        return (Predicate<T>)target.negate();
    }
}
```

#### Basic Usage Examples:
```java
public class PredicateExamples {
    
    public void basicPredicateUsage() {
        // Simple predicate
        Predicate<Integer> isEven = n -> n % 2 == 0;
        System.out.println("Is 4 even? " + isEven.test(4)); // true
        System.out.println("Is 5 even? " + isEven.test(5)); // false
        
        // String predicates
        Predicate<String> isEmpty = String::isEmpty;
        Predicate<String> startsWithA = s -> s.startsWith("A");
        Predicate<String> isLongEnough = s -> s.length() > 5;
        
        System.out.println("Is '' empty? " + isEmpty.test(""));
        System.out.println("Does 'Alice' start with A? " + startsWithA.test("Alice"));
        System.out.println("Is 'Hello World' long enough? " + isLongEnough.test("Hello World"));
        
        // Method reference predicates
        List<String> words = Arrays.asList("apple", "", "banana", "cherry");
        Predicate<String> notEmpty = Predicate.not(String::isEmpty);
        
        List<String> nonEmptyWords = words.stream()
            .filter(notEmpty)
            .collect(Collectors.toList());
        System.out.println("Non-empty words: " + nonEmptyWords);
    }
    
    public void demonstratePredicateComposition() {
        // Individual predicates
        Predicate<String> notNull = Objects::nonNull;
        Predicate<String> notEmpty = s -> !s.isEmpty();
        Predicate<String> notBlank = s -> !s.trim().isEmpty();
        Predicate<String> maxLength = s -> s.length() <= 50;
        Predicate<String> containsAlphabetic = s -> s.matches(".*[a-zA-Z].*");
        
        // Combine predicates using and()
        Predicate<String> validString = notNull
            .and(notEmpty)
            .and(notBlank)
            .and(maxLength)
            .and(containsAlphabetic);
        
        // Test strings
        List<String> testStrings = Arrays.asList(
            "Valid String",
            null,
            "",
            "   ",
            "This is a very long string that exceeds fifty characters and should be rejected",
            "12345",
            "Hello123"
        );
        
        testStrings.forEach(s -> {
            boolean isValid = validString.test(s);
            System.out.println("'" + s + "' is " + (isValid ? "valid" : "invalid"));
        });
        
        // Using or() and negate()
        Predicate<Integer> isSmall = n -> n < 10;
        Predicate<Integer> isLarge = n -> n > 100;
        Predicate<Integer> isExtremeSize = isSmall.or(isLarge);
        Predicate<Integer> isNormalSize = isExtremeSize.negate();
        
        List<Integer> numbers = Arrays.asList(5, 25, 50, 75, 150);
        List<Integer> normalSizeNumbers = numbers.stream()
            .filter(isNormalSize)
            .collect(Collectors.toList());
        System.out.println("Normal size numbers: " + normalSizeNumbers);
    }
}
```

#### Predicate Variants:
```java
public class PredicateVariants {
    
    public void demonstratePredicateVariants() {
        // BiPredicate - tests two arguments
        BiPredicate<String, String> startsWith = String::startsWith;
        System.out.println("Does 'Hello' start with 'He'? " + startsWith.test("Hello", "He"));
        
        BiPredicate<Integer, Integer> isGreater = (a, b) -> a > b;
        System.out.println("Is 10 > 5? " + isGreater.test(10, 5));
        
        // IntPredicate - specialized for int
        IntPredicate isPositive = n -> n > 0;
        IntPredicate isEven = n -> n % 2 == 0;
        IntPredicate isPositiveEven = isPositive.and(isEven);
        
        IntStream.rangeClosed(-5, 5)
            .filter(isPositiveEven)
            .forEach(n -> System.out.println("Positive even: " + n));
        
        // LongPredicate - specialized for long
        LongPredicate isLargeNumber = n -> n > 1_000_000L;
        System.out.println("Is 2,000,000 large? " + isLargeNumber.test(2_000_000L));
        
        // DoublePredicate - specialized for double
        DoublePredicate isNearZero = d -> Math.abs(d) < 0.001;
        System.out.println("Is 0.0005 near zero? " + isNearZero.test(0.0005));
        System.out.println("Is 0.5 near zero? " + isNearZero.test(0.5));
    }
}
```

#### Advanced Predicate Patterns:
```java
public class AdvancedPredicatePatterns {
    
    // Create predicate from multiple conditions
    @SafeVarargs
    public static <T> Predicate<T> allOf(Predicate<T>... predicates) {
        return Arrays.stream(predicates)
            .reduce(t -> true, Predicate::and);
    }
    
    @SafeVarargs
    public static <T> Predicate<T> anyOf(Predicate<T>... predicates) {
        return Arrays.stream(predicates)
            .reduce(t -> false, Predicate::or);
    }
    
    @SafeVarargs
    public static <T> Predicate<T> noneOf(Predicate<T>... predicates) {
        return anyOf(predicates).negate();
    }
    
    // Predicate builder for complex conditions
    public static class PredicateBuilder<T> {
        private Predicate<T> predicate = t -> true;
        
        public PredicateBuilder<T> and(Predicate<T> condition) {
            predicate = predicate.and(condition);
            return this;
        }
        
        public PredicateBuilder<T> or(Predicate<T> condition) {
            predicate = predicate.or(condition);
            return this;
        }
        
        public PredicateBuilder<T> negate() {
            predicate = predicate.negate();
            return this;
        }
        
        public Predicate<T> build() {
            return predicate;
        }
    }
    
    // Range predicate
    public static <T extends Comparable<T>> Predicate<T> inRange(T min, T max) {
        return value -> value.compareTo(min) >= 0 && value.compareTo(max) <= 0;
    }
    
    // Collection-based predicates
    public static <T> Predicate<T> isIn(Collection<T> collection) {
        return collection::contains;
    }
    
    public static <T> Predicate<T> isNotIn(Collection<T> collection) {
        return isIn(collection).negate();
    }
    
    public void demonstrateAdvancedPatterns() {
        // Using composite predicates
        Predicate<Integer> isPositive = n -> n > 0;
        Predicate<Integer> isEven = n -> n % 2 == 0;
        Predicate<Integer> isLessThan100 = n -> n < 100;
        
        Predicate<Integer> complexCondition = allOf(isPositive, isEven, isLessThan100);
        
        List<Integer> numbers = Arrays.asList(-5, 0, 2, 10, 25, 50, 101, 200);
        List<Integer> filtered = numbers.stream()
            .filter(complexCondition)
            .collect(Collectors.toList());
        System.out.println("Numbers that are positive, even, and < 100: " + filtered);
        
        // Using predicate builder
        Predicate<String> emailPredicate = new PredicateBuilder<String>()
            .and(Objects::nonNull)
            .and(s -> !s.isEmpty())
            .and(s -> s.contains("@"))
            .and(s -> s.contains("."))
            .and(s -> s.length() < 255)
            .build();
        
        List<String> emails = Arrays.asList("valid@email.com", "invalid", null, "", "too@short");
        emails.forEach(email -> {
            boolean isValid = emailPredicate.test(email);
            System.out.println("Email '" + email + "' is " + (isValid ? "valid" : "invalid"));
        });
        
        // Range predicate
        Predicate<Integer> inRange = inRange(10, 50);
        System.out.println("Is 25 in range [10, 50]? " + inRange.test(25));
        System.out.println("Is 75 in range [10, 50]? " + inRange.test(75));
        
        // Collection-based predicate
        Set<String> validStatuses = Set.of("ACTIVE", "PENDING", "COMPLETED");
        Predicate<String> isValidStatus = isIn(validStatuses);
        
        List<String> statuses = Arrays.asList("ACTIVE", "INVALID", "PENDING", "EXPIRED");
        List<String> validOnes = statuses.stream()
            .filter(isValidStatus)
            .collect(Collectors.toList());
        System.out.println("Valid statuses: " + validOnes);
        
        // Conditional validation based on object properties
        Predicate<Person> isAdult = person -> person.getAge() >= 18;
        Predicate<Person> hasValidEmail = person -> 
            person.getEmail() != null && person.getEmail().contains("@");
        Predicate<Person> isEmployeeEligible = isAdult.and(hasValidEmail);
        
        List<Person> people = Arrays.asList(
            new Person("Alice", 25, "alice@example.com"),
            new Person("Bob", 16, "bob@example.com"),
            new Person("Charlie", 30, "invalid-email"),
            new Person("Diana", 22, "diana@example.com")
        );
        
        List<Person> eligibleEmployees = people.stream()
            .filter(isEmployeeEligible)
            .collect(Collectors.toList());
        System.out.println("Eligible employees: " + 
            eligibleEmployees.stream().map(Person::getName).collect(Collectors.toList()));
    }
}

// Supporting classes
class Person {
    private String name;
    private int age;
    private String email;
    private LocalDateTime lastProcessed;
    
    public Person(String name, int age) {
        this.name = name;
        this.age = age;
    }
    
    public Person(String name, int age, String email) {
        this.name = name;
        this.age = age;
        this.email = email;
    }
    
    // Getters and setters
    public String getName() { return name; }
    public int getAge() { return age; }
    public String getEmail() { return email; }
    public LocalDateTime getLastProcessed() { return lastProcessed; }
    public void setLastProcessed(LocalDateTime lastProcessed) { this.lastProcessed = lastProcessed; }
    
    @Override
    public String toString() {
        return "Person{name='" + name + "', age=" + age + ", email='" + email + "'}";
    }
}

## 5. Inheritance and Extension Scenarios - Complex Interface Hierarchies

When functional interfaces extend from other interfaces, the rules for maintaining functional interface status become more complex. Understanding these scenarios is crucial for designing robust functional interface hierarchies.

### 5.1 Functional Interface Extending Non-Functional Interface

When a functional interface extends a non-functional interface, it must still have exactly one abstract method to remain functional.

#### Basic Extension Example:
```java
// Non-functional interface with multiple abstract methods
public interface MultiMethodInterface {
    void method1();
    void method2();
    String method3(int param);
}

// To make it functional, provide default implementations for all but one method
@FunctionalInterface
public interface ValidFunctionalInterface extends MultiMethodInterface {
    // Provide default implementations for all but one method
    @Override
    default void method1() {
        System.out.println("Default implementation of method1");
    }
    
    @Override
    default String method3(int param) {
        return "Default implementation with param: " + param;
    }
    
    // method2() remains abstract - this is our single abstract method
}

// Usage example
public class ExtensionExample {
    public void demonstrateValidExtension() {
        // Can use as functional interface
        ValidFunctionalInterface func = () -> System.out.println("Lambda implementation of method2");
        
        func.method1(); // Calls default implementation
        func.method2(); // Calls lambda implementation
        System.out.println(func.method3(42)); // Calls default implementation
    }
}
```

### 5.2 Functional Interface Extending Another Functional Interface

When a functional interface extends another functional interface, the result is still functional if exactly one abstract method remains.

#### Same Abstract Method Signature:
```java
// Parent functional interface
@FunctionalInterface
public interface ParentFunction<T, R> {
    R apply(T input);
    
    default R applyWithLogging(T input) {
        System.out.println("Applying function to: " + input);
        R result = apply(input);
        System.out.println("Result: " + result);
        return result;
    }
}

// Child functional interface with same abstract method
@FunctionalInterface
public interface ChildFunction<T, R> extends ParentFunction<T, R> {
    // Inherits apply(T input) - still only one abstract method
    
    // Can add default methods
    default R applyWithValidation(T input) {
        if (input == null) {
            throw new IllegalArgumentException("Input cannot be null");
        }
        return apply(input);
    }
    
    // Can override inherited default methods
    @Override
    default R applyWithLogging(T input) {
        System.out.println("Enhanced logging - Input type: " + input.getClass().getSimpleName());
        return ParentFunction.super.applyWithLogging(input);
    }
}
```

### 5.3 Handling Conflicts and Ambiguities

#### Multiple Interface Inheritance with Conflicts:
```java
// First functional interface
@FunctionalInterface
public interface Validator<T> {
    boolean isValid(T item);
    
    default ValidationResult validate(T item) {
        boolean valid = isValid(item);
        return new ValidationResult(valid, valid ? "Valid" : "Invalid");
    }
}

// Second functional interface with conflicting default method
@FunctionalInterface
public interface Checker<T> {
    boolean check(T item);
    
    default ValidationResult validate(T item) {
        boolean valid = check(item);
        return new ValidationResult(valid, valid ? "Passed" : "Failed");
    }
}

// Functional interface that must resolve conflict
@FunctionalInterface
public interface ValidatorChecker<T> extends Validator<T>, Checker<T> {
    // To make it functional, provide default implementation for one abstract method
    @Override
    default boolean check(T item) {
        return isValid(item); // Delegate to the single abstract method
    }
    
    // Must resolve the validate() method conflict
    @Override
    default ValidationResult validate(T item) {
        boolean valid = isValid(item);
        return new ValidationResult(valid, 
            valid ? "Validation passed" : "Validation failed");
    }
}

class ValidationResult {
    private final boolean valid;
    private final String message;
    
    public ValidationResult(boolean valid, String message) {
        this.valid = valid;
        this.message = message;
    }
    
    public boolean isValid() { return valid; }
    public String getErrorMessage() { return message; }
    
    @Override
    public String toString() {
        return "ValidationResult{valid=" + valid + ", message='" + message + "'}";
    }
}
```

### 5.4 Best Practices and Common Pitfalls

#### Best Practice: Clear Single Responsibility
```java
@FunctionalInterface
public interface DataFilter<T> {
    boolean accept(T item);
    
    // Related utility methods
    default DataFilter<T> and(DataFilter<T> other) {
        return item -> accept(item) && other.accept(item);
    }
    
    default DataFilter<T> or(DataFilter<T> other) {
        return item -> accept(item) || other.accept(item);
    }
    
    default DataFilter<T> negate() {
        return item -> !accept(item);
    }
}
```

#### Common Pitfall: Accidentally Creating Non-Functional Interfaces
```java
// BAD: This is NOT a functional interface
/*
@FunctionalInterface  // Compilation error
public interface BadExample extends Comparable<BadExample> {
    void process();
    // Comparable adds: int compareTo(BadExample other)
    // Total: 2 abstract methods - NOT functional!
}
*/

// GOOD: Provide default implementation for inherited abstract methods
@FunctionalInterface
public interface GoodExample extends Comparable<GoodExample> {
    void process();
    
    // Provide default implementation for inherited method
    @Override
    default int compareTo(GoodExample other) {
        return Integer.compare(this.hashCode(), other.hashCode());
    }
}
```

### 5.5 Real-World Application Example

#### Building a Configurable Processing Pipeline:
```java
@FunctionalInterface
public interface DataProcessor<T> {
    T process(T input);
    
    default DataProcessor<T> andThen(DataProcessor<T> after) {
        return input -> after.process(process(input));
    }
    
    default DataProcessor<T> withRetry(int maxAttempts) {
        return input -> {
            T result = null;
            Exception lastException = null;
            
            for (int i = 0; i < maxAttempts; i++) {
                try {
                    result = process(input);
                    break;
                } catch (Exception e) {
                    lastException = e;
                }
            }
            
            if (result == null && lastException != null) {
                throw new RuntimeException("Processing failed after " + maxAttempts + " attempts", lastException);
            }
            
            return result;
        };
    }
}

@FunctionalInterface
public interface StringProcessor extends DataProcessor<String> {
    // Inherits: String process(String input)
    
    default StringProcessor normalize() {
        return input -> process(input).trim().toLowerCase();
    }
    
    default StringProcessor validateNotEmpty() {
        return input -> {
            String result = process(input);
            if (result == null || result.isEmpty()) {
                throw new IllegalArgumentException("Result cannot be empty");
            }
            return result;
        };
    }
    
    static StringProcessor removeSpecialChars() {
        return input -> input.replaceAll("[^a-zA-Z0-9\\s]", "");
    }
}

// Usage example
public class ProcessingPipelineExample {
    public void demonstrateProcessingPipeline() {
        // Build a processing pipeline
        StringProcessor processor = StringProcessor.removeSpecialChars()
            .andThen(String::toUpperCase)
            .normalize()
            .validateNotEmpty()
            .withRetry(3);
        
        String input = "  Hello, World! @#$  ";
        String result = processor.process(input);
        System.out.println("Input: '" + input + "'");
        System.out.println("Result: '" + result + "'");
    }
}
```

## Key Takeaways

### Essential Concepts:
1. **Functional Interfaces**: Interfaces with exactly one abstract method
2. **Lambda Functions**: Anonymous functions enabling concise functional programming
3. **Built-in Interfaces**: Consumer, Supplier, Function, Predicate with their variants
4. **Inheritance Rules**: Complex scenarios when extending interfaces
5. **Best Practices**: Design patterns for maintainable functional interfaces

### Design Guidelines:
1. Always use `@FunctionalInterface` annotation
2. Keep interfaces focused on single responsibility
3. Provide meaningful default methods
4. Handle inheritance conflicts explicitly
5. Use static methods for utilities and factories

Functional interfaces have revolutionized Java programming by enabling functional paradigms, improving code readability, and providing powerful abstractions for modern development patterns.
